## API Report File for "@jupyterlab/notebook"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { ABCWidgetFactory } from '@jupyterlab/docregistry';
import { Cell } from '@jupyterlab/cells';
import { CellModel } from '@jupyterlab/cells';
import { CodeCell } from '@jupyterlab/cells';
import { CodeCellModel } from '@jupyterlab/cells';
import { CodeEditor } from '@jupyterlab/codeeditor';
import { ConflatableMessage } from '@phosphor/messaging';
import { Contents } from '@jupyterlab/services';
import { DocumentModel } from '@jupyterlab/docregistry';
import { DocumentRegistry } from '@jupyterlab/docregistry';
import { DocumentWidget } from '@jupyterlab/docregistry';
import { ICellModel } from '@jupyterlab/cells';
import { IChangedArgs } from '@jupyterlab/coreutils';
import { IClientSession } from '@jupyterlab/apputils';
import { ICodeCellModel } from '@jupyterlab/cells';
import { IEditorMimeTypeService } from '@jupyterlab/codeeditor';
import { IMarkdownCellModel } from '@jupyterlab/cells';
import { IModelDB } from '@jupyterlab/observables';
import { IObservableJSON } from '@jupyterlab/observables';
import { IObservableMap } from '@jupyterlab/observables';
import { IObservableUndoableList } from '@jupyterlab/observables';
import { IRawCellModel } from '@jupyterlab/cells';
import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
import { ISignal } from '@phosphor/signaling';
import { IWidgetTracker } from '@jupyterlab/apputils';
import { JSONEditor } from '@jupyterlab/codeeditor';
import { JSONValue } from '@phosphor/coreutils';
import { MarkdownCell } from '@jupyterlab/cells';
import { Message } from '@phosphor/messaging';
import { nbformat } from '@jupyterlab/coreutils';
import { ObservableJSON } from '@jupyterlab/observables';
import { Printing } from '@jupyterlab/apputils';
import { RawCell } from '@jupyterlab/cells';
import * as React from 'react';
import { ReactWidget } from '@jupyterlab/apputils';
import { Token } from '@phosphor/coreutils';
import { VDomModel } from '@jupyterlab/apputils';
import { VDomRenderer } from '@jupyterlab/apputils';
import { Widget } from '@phosphor/widgets';
import { WidgetTracker } from '@jupyterlab/apputils';

// @public
export class CellTypeSwitcher extends ReactWidget {
  constructor(widget: Notebook);
  handleChange: (event: React.ChangeEvent<HTMLSelectElement>) => void;
  handleKeyDown: (event: React.KeyboardEvent<Element>) => void;
  // (undocumented)
  render(): JSX.Element;
}

// @public
export class CommandEditStatus extends VDomRenderer<CommandEditStatus.Model> {
  constructor();
  render(): JSX.Element;
}

// @public
export namespace CommandEditStatus {
  export class Model extends VDomModel {
    notebook: Notebook | null;
    readonly notebookMode: NotebookMode;
  }
}

// @public
export interface INotebookModel extends DocumentRegistry.IModel {
  readonly cells: IObservableUndoableList<ICellModel>;
  readonly contentFactory: NotebookModel.IContentFactory;
  readonly deletedCells: string[];
  readonly metadata: IObservableJSON;
  readonly nbformat: number;
  readonly nbformatMinor: number;
}

// @public
export const INotebookTools: Token<INotebookTools>;

// @public
export interface INotebookTools extends Widget {
  // (undocumented)
  activeCell: Cell | null;
  // (undocumented)
  activeNotebookPanel: NotebookPanel | null;
  // (undocumented)
  addItem(options: NotebookTools.IAddOptions): void;
  // (undocumented)
  selectedCells: Cell[];
}

// @public
export namespace INotebookTools {
  export interface IAddOptions {
    rank?: number;
    section?: 'common' | 'advanced';
    tool: ITool;
  }
  // (undocumented)
  export interface ITool extends Widget {
    notebookTools: INotebookTools;
  }
}

// @public
export const INotebookTracker: Token<INotebookTracker>;

// @public
export interface INotebookTracker extends IWidgetTracker<NotebookPanel> {
  readonly activeCell: Cell;
  readonly activeCellChanged: ISignal<this, Cell>;
  readonly selectionChanged: ISignal<this, void>;
}

// @public
export class Notebook extends StaticNotebook {
  constructor(options: Notebook.IOptions);
  readonly activeCell: Cell | null;
  readonly activeCellChanged: ISignal<this, Cell>;
  activeCellIndex: number;
  deselect(widget: Cell): void;
  deselectAll(): void;
  dispose(): void;
  extendContiguousSelectionTo(index: number): void;
  getContiguousSelection(): {
    head: number | null;
    anchor: number | null;
  };
  handleEvent(event: Event): void;
  isSelected(widget: Cell): boolean;
  isSelectedOrActive(widget: Cell): boolean;
  mode: NotebookMode;
  protected onActivateRequest(msg: Message): void;
  protected onAfterAttach(msg: Message): void;
  protected onAfterShow(msg: Message): void;
  protected onBeforeDetach(msg: Message): void;
  protected onBeforeHide(msg: Message): void;
  protected onCellInserted(index: number, cell: Cell): void;
  protected onCellMoved(fromIndex: number, toIndex: number): void;
  protected onCellRemoved(index: number, cell: Cell): void;
  protected onModelChanged(
    oldValue: INotebookModel,
    newValue: INotebookModel
  ): void;
  protected onResize(msg: Widget.ResizeMessage): void;
  protected onUpdateRequest(msg: Message): void;
  scrollToPosition(position: number, threshold?: number): void;
  select(widget: Cell): void;
  readonly selectionChanged: ISignal<this, void>;
  setFragment(fragment: string): void;
  readonly stateChanged: ISignal<this, IChangedArgs<any>>;
}

// @public
export namespace Notebook {
  export class ContentFactory extends StaticNotebook.ContentFactory {}
  export namespace ContentFactory {
    export interface IOptions extends StaticNotebook.ContentFactory.IOptions {}
  }
  export interface IContentFactory extends StaticNotebook.IContentFactory {}
  export interface IOptions extends StaticNotebook.IOptions {}
  const // (undocumented)
    defaultContentFactory: IContentFactory;
}

// @public
export class NotebookActions {
  static readonly executed: ISignal<
    any,
    {
      notebook: Notebook;
      cell: Cell;
    }
  >;
}

// @public
export namespace NotebookActions {
  export function changeCellType(
    notebook: Notebook,
    value: nbformat.CellType
  ): void;
  export function clearAllOutputs(notebook: Notebook): void;
  export function clearOutputs(notebook: Notebook): void;
  export function copy(notebook: Notebook): void;
  export function cut(notebook: Notebook): void;
  export function deleteCells(notebook: Notebook): void;
  export function deselectAll(notebook: Notebook): void;
  export function disableOutputScrolling(notebook: Notebook): void;
  export function enableOutputScrolling(notebook: Notebook): void;
  export function extendSelectionAbove(
    notebook: Notebook,
    toTop?: boolean
  ): void;
  export function extendSelectionBelow(
    notebook: Notebook,
    toBottom?: boolean
  ): void;
  export function hideAllCode(notebook: Notebook): void;
  export function hideAllOutputs(notebook: Notebook): void;
  export function hideCode(notebook: Notebook): void;
  export function hideOutput(notebook: Notebook): void;
  export function insertAbove(notebook: Notebook): void;
  export function insertBelow(notebook: Notebook): void;
  export function mergeCells(notebook: Notebook): void;
  export function moveDown(notebook: Notebook): void;
  export function moveUp(notebook: Notebook): void;
  export function paste(
    notebook: Notebook,
    mode?: 'below' | 'above' | 'replace'
  ): void;
  export function redo(notebook: Notebook): void;
  // (undocumented)
  export function renderAllMarkdown(
    notebook: Notebook,
    session?: IClientSession
  ): Promise<boolean>;
  export function run(
    notebook: Notebook,
    session?: IClientSession
  ): Promise<boolean>;
  export function runAll(
    notebook: Notebook,
    session?: IClientSession
  ): Promise<boolean>;
  export function runAllAbove(
    notebook: Notebook,
    session?: IClientSession
  ): Promise<boolean>;
  export function runAllBelow(
    notebook: Notebook,
    session?: IClientSession
  ): Promise<boolean>;
  export function runAndAdvance(
    notebook: Notebook,
    session?: IClientSession
  ): Promise<boolean>;
  export function runAndInsert(
    notebook: Notebook,
    session?: IClientSession
  ): Promise<boolean>;
  export function selectAbove(notebook: Notebook): void;
  export function selectAll(notebook: Notebook): void;
  export function selectBelow(notebook: Notebook): void;
  export function setMarkdownHeader(notebook: Notebook, level: number): void;
  export function showAllCode(notebook: Notebook): void;
  export function showAllOutputs(notebook: Notebook): void;
  export function showCode(notebook: Notebook): void;
  export function showOutput(notebook: Notebook): void;
  export function splitCell(notebook: Notebook): void;
  export function toggleAllLineNumbers(notebook: Notebook): void;
  export function toggleRecordTiming(notebook: Notebook): void;
  export function trust(notebook: Notebook): Promise<void>;
  export function undo(notebook: Notebook): void;
}

// @public
export type NotebookMode = 'command' | 'edit';

// @public
export class NotebookModel extends DocumentModel implements INotebookModel {
  constructor(options?: NotebookModel.IOptions);
  readonly cells: IObservableUndoableList<ICellModel>;
  readonly contentFactory: NotebookModel.IContentFactory;
  readonly defaultKernelLanguage: string;
  readonly defaultKernelName: string;
  readonly deletedCells: string[];
  dispose(): void;
  fromJSON(value: nbformat.INotebookContent): void;
  fromString(value: string): void;
  initialize(): void;
  readonly metadata: IObservableJSON;
  readonly nbformat: number;
  readonly nbformatMinor: number;
  toJSON(): nbformat.INotebookContent;
  toString(): string;
}

// @public
export namespace NotebookModel {
  export class ContentFactory {
    constructor(options: ContentFactory.IOptions);
    clone(modelDB: IModelDB): ContentFactory;
    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
    createCell(type: nbformat.CellType, opts: CellModel.IOptions): ICellModel;
    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel;
    createMarkdownCell(options: CellModel.IOptions): IMarkdownCellModel;
    createRawCell(options: CellModel.IOptions): IRawCellModel;
    readonly modelDB: IModelDB | undefined;
  }
  export namespace ContentFactory {
    export interface IOptions {
      codeCellContentFactory?: CodeCellModel.IContentFactory;
      modelDB?: IModelDB;
    }
  }
  export interface IContentFactory {
    clone(modelDB: IModelDB): IContentFactory;
    readonly codeCellContentFactory: CodeCellModel.IContentFactory;
    createCell(type: nbformat.CellType, opts: CellModel.IOptions): ICellModel;
    createCodeCell(options: CodeCellModel.IOptions): ICodeCellModel;
    createMarkdownCell(options: CellModel.IOptions): IMarkdownCellModel;
    createRawCell(options: CellModel.IOptions): IRawCellModel;
    modelDB: IModelDB;
  }
  export interface IOptions {
    contentFactory?: IContentFactory;
    languagePreference?: string;
    modelDB?: IModelDB;
  }
  const defaultContentFactory: ContentFactory;
}

// @public
export class NotebookModelFactory
  implements DocumentRegistry.IModelFactory<INotebookModel> {
  constructor(options: NotebookModelFactory.IOptions);
  readonly contentFactory: NotebookModel.IContentFactory;
  readonly contentType: Contents.ContentType;
  createNew(languagePreference?: string, modelDB?: IModelDB): INotebookModel;
  dispose(): void;
  readonly fileFormat: Contents.FileFormat;
  readonly isDisposed: boolean;
  readonly name: string;
  preferredLanguage(path: string): string;
}

// @public
export namespace NotebookModelFactory {
  export interface IOptions {
    codeCellContentFactory?: CodeCellModel.IContentFactory;
    contentFactory?: NotebookModel.IContentFactory;
  }
}

// @public
export class NotebookPanel extends DocumentWidget<Notebook, INotebookModel> {
  [Printing.symbol](): () => Promise<void>;
  constructor(options: DocumentWidget.IOptions<Notebook, INotebookModel>);
  readonly activated: ISignal<this, void>;
  readonly content: Notebook;
  dispose(): void;
  readonly model: INotebookModel;
  protected onActivateRequest(msg: Message): void;
  // (undocumented)
  _onSave(
    sender: DocumentRegistry.Context,
    state: DocumentRegistry.SaveState
  ): void;
  readonly session: IClientSession;
  setConfig(config: NotebookPanel.IConfig): void;
  setFragment(fragment: string): void;
}

// @public
export namespace NotebookPanel {
  export class ContentFactory extends Notebook.ContentFactory
    implements IContentFactory {
    createNotebook(options: Notebook.IOptions): Notebook;
  }
  export interface IConfig {
    editorConfig: StaticNotebook.IEditorConfig;
    kernelShutdown: boolean;
    notebookConfig: StaticNotebook.INotebookConfig;
  }
  export interface IContentFactory extends Notebook.IContentFactory {
    createNotebook(options: Notebook.IOptions): Notebook;
  }
  const defaultContentFactory: ContentFactory;
  const IContentFactory: Token<IContentFactory>;
}

// @public
export class NotebookTools extends Widget implements INotebookTools {
  constructor(options: NotebookTools.IOptions);
  readonly activeCell: Cell | null;
  readonly activeNotebookPanel: NotebookPanel | null;
  addItem(options: NotebookTools.IAddOptions): void;
  readonly selectedCells: Cell[];
}

// @public
export namespace NotebookTools {
  export class ActiveCellTool extends Tool {
    constructor();
    dispose(): void;
    protected onActiveCellChanged(): void;
  }
  export class CellMetadataEditorTool extends MetadataEditorTool {
    constructor(options: MetadataEditorTool.IOptions);
    protected onActiveCellChanged(msg: Message): void;
    protected onActiveCellMetadataChanged(msg: Message): void;
  }
  const ActiveNotebookPanelMessage: ConflatableMessage;
  const ActiveCellMessage: ConflatableMessage;
  const SelectionMessage: ConflatableMessage;
  export function createNBConvertSelector(optionsMap: {
    [key: string]: JSONValue;
  }): KeySelector;
  export function createSlideShowSelector(): KeySelector;
  export interface IAddOptions {
    rank?: number;
    section?: 'common' | 'advanced';
    tool: Tool;
  }
  export interface IOptions {
    tracker: INotebookTracker;
  }
  export class KeySelector extends Tool {
    constructor(options: KeySelector.IOptions);
    handleEvent(event: Event): void;
    readonly key: string;
    protected onActiveCellChanged(msg: Message): void;
    protected onActiveCellMetadataChanged(
      msg: ObservableJSON.ChangeMessage
    ): void;
    protected onAfterAttach(msg: Message): void;
    protected onBeforeDetach(msg: Message): void;
    protected onValueChanged(): void;
    readonly selectNode: HTMLSelectElement;
  }
  export namespace KeySelector {
    export interface IOptions {
      default?: JSONValue;
      getter?: (cell: Cell) => JSONValue;
      key: string;
      optionsMap: {
        [key: string]: JSONValue;
      };
      setter?: (cell: Cell, value: JSONValue) => void;
      title?: string;
      validCellTypes?: nbformat.CellType[];
    }
  }
  export class MetadataEditorTool extends Tool {
    constructor(options: MetadataEditorTool.IOptions);
    readonly editor: JSONEditor;
  }
  export namespace MetadataEditorTool {
    export interface IOptions {
      collapsed?: boolean;
      editorFactory: CodeEditor.Factory;
      label?: string;
    }
  }
  export class NotebookMetadataEditorTool extends MetadataEditorTool {
    constructor(options: MetadataEditorTool.IOptions);
    protected onActiveNotebookPanelChanged(msg: Message): void;
    protected onActiveNotebookPanelMetadataChanged(msg: Message): void;
  }
  export class Tool extends Widget implements INotebookTools.ITool {
    // (undocumented)
    dispose(): void;
    notebookTools: INotebookTools;
    protected onActiveCellChanged(msg: Message): void;
    protected onActiveCellMetadataChanged(
      msg: ObservableJSON.ChangeMessage
    ): void;
    protected onActiveNotebookPanelChanged(msg: Message): void;
    protected onActiveNotebookPanelMetadataChanged(
      msg: ObservableJSON.ChangeMessage
    ): void;
    protected onSelectionChanged(msg: Message): void;
    processMessage(msg: Message): void;
  }
}

// @public (undocumented)
export class NotebookTracker extends WidgetTracker<NotebookPanel>
  implements INotebookTracker {
  readonly activeCell: Cell;
  readonly activeCellChanged: ISignal<this, Cell>;
  add(panel: NotebookPanel): Promise<void>;
  dispose(): void;
  protected onCurrentChanged(widget: NotebookPanel): void;
  readonly selectionChanged: ISignal<this, void>;
}

// @public
export class NotebookTrustStatus extends VDomRenderer<
  NotebookTrustStatus.Model
> {
  constructor();
  render(): JSX.Element;
}

// @public
export namespace NotebookTrustStatus {
  export class Model extends VDomModel {
    readonly activeCellTrusted: boolean;
    notebook: Notebook | null;
    readonly totalCells: number;
    readonly trustedCells: number;
  }
}

// @public
export class NotebookWidgetFactory extends ABCWidgetFactory<
  NotebookPanel,
  INotebookModel
> {
  constructor(options: NotebookWidgetFactory.IOptions<NotebookPanel>);
  readonly contentFactory: NotebookPanel.IContentFactory;
  protected createNewWidget(
    context: DocumentRegistry.IContext<INotebookModel>,
    source?: NotebookPanel
  ): NotebookPanel;
  protected defaultToolbarFactory(
    widget: NotebookPanel
  ): DocumentRegistry.IToolbarItem[];
  editorConfig: StaticNotebook.IEditorConfig;
  readonly mimeTypeService: IEditorMimeTypeService;
  notebookConfig: StaticNotebook.INotebookConfig;
  // (undocumented)
  readonly rendermime: IRenderMimeRegistry;
}

// @public
export namespace NotebookWidgetFactory {
  export interface IOptions<T extends NotebookPanel>
    extends DocumentRegistry.IWidgetFactoryOptions<T> {
    contentFactory: NotebookPanel.IContentFactory;
    editorConfig?: StaticNotebook.IEditorConfig;
    mimeTypeService: IEditorMimeTypeService;
    notebookConfig?: StaticNotebook.INotebookConfig;
    // (undocumented)
    rendermime: IRenderMimeRegistry;
  }
}

// @public
export class StaticNotebook extends Widget {
  constructor(options: StaticNotebook.IOptions);
  readonly codeMimetype: string;
  readonly contentFactory: StaticNotebook.IContentFactory;
  dispose(): void;
  editorConfig: StaticNotebook.IEditorConfig;
  model: INotebookModel;
  readonly modelChanged: ISignal<this, void>;
  readonly modelContentChanged: ISignal<this, void>;
  notebookConfig: StaticNotebook.INotebookConfig;
  protected onCellInserted(index: number, cell: Cell): void;
  protected onCellMoved(fromIndex: number, toIndex: number): void;
  protected onCellRemoved(index: number, cell: Cell): void;
  protected onMetadataChanged(
    sender: IObservableMap<JSONValue>,
    args: IObservableMap.IChangedArgs<JSONValue>
  ): void;
  protected onModelChanged(
    oldValue: INotebookModel,
    newValue: INotebookModel
  ): void;
  protected onModelContentChanged(model: INotebookModel, args: void): void;
  readonly rendermime: IRenderMimeRegistry;
  readonly widgets: ReadonlyArray<Cell>;
}

// @public
export namespace StaticNotebook {
  export class ContentFactory extends Cell.ContentFactory
    implements IContentFactory {
    createCodeCell(
      options: CodeCell.IOptions,
      parent: StaticNotebook
    ): CodeCell;
    createMarkdownCell(
      options: MarkdownCell.IOptions,
      parent: StaticNotebook
    ): MarkdownCell;
    createRawCell(options: RawCell.IOptions, parent: StaticNotebook): RawCell;
  }
  export namespace ContentFactory {
    export interface IOptions extends Cell.ContentFactory.IOptions {}
  }
  export interface IContentFactory extends Cell.IContentFactory {
    createCodeCell(
      options: CodeCell.IOptions,
      parent: StaticNotebook
    ): CodeCell;
    createMarkdownCell(
      options: MarkdownCell.IOptions,
      parent: StaticNotebook
    ): MarkdownCell;
    createRawCell(options: RawCell.IOptions, parent: StaticNotebook): RawCell;
  }
  const defaultEditorConfig: IEditorConfig;
  export interface IEditorConfig {
    readonly code: Partial<CodeEditor.IConfig>;
    readonly markdown: Partial<CodeEditor.IConfig>;
    readonly raw: Partial<CodeEditor.IConfig>;
  }
  const defaultNotebookConfig: INotebookConfig;
  export interface INotebookConfig {
    defaultCell: nbformat.CellType;
    scrollPastEnd: boolean;
  }
  export interface IOptions {
    contentFactory?: IContentFactory;
    editorConfig?: IEditorConfig;
    languagePreference?: string;
    mimeTypeService: IEditorMimeTypeService;
    notebookConfig?: INotebookConfig;
    rendermime: IRenderMimeRegistry;
  }
  const defaultContentFactory: IContentFactory;
}

// @public
export namespace ToolbarItems {
  export function createCellTypeItem(panel: NotebookPanel): Widget;
  export function createCopyButton(panel: NotebookPanel): Widget;
  export function createCutButton(panel: NotebookPanel): Widget;
  export function createInsertButton(panel: NotebookPanel): Widget;
  export function createPasteButton(panel: NotebookPanel): Widget;
  export function createRunButton(panel: NotebookPanel): Widget;
  export function createSaveButton(panel: NotebookPanel): Widget;
  export function getDefaultItems(
    panel: NotebookPanel
  ): DocumentRegistry.IToolbarItem[];
}

// (No @packageDocumentation comment for this package)
```
