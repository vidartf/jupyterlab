## API Report File for "@jupyterlab/rendermime"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { Contents } from '@jupyterlab/services';
import { IClientSession } from '@jupyterlab/apputils';
import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
import { ISanitizer } from '@jupyterlab/apputils';
import { ISignal } from '@phosphor/signaling';
import { JSONObject } from '@phosphor/coreutils';
import { Message } from '@phosphor/messaging';
import { nbformat } from '@jupyterlab/coreutils';
import { ReadonlyJSONObject } from '@phosphor/coreutils';
import { Session } from '@jupyterlab/services';
import { Token } from '@phosphor/coreutils';
import { Widget } from '@phosphor/widgets';

// @public
export class AttachmentModel implements IAttachmentModel {
  constructor(options: IAttachmentModel.IOptions);
  readonly changed: ISignal<this, void>;
  readonly data: ReadonlyJSONObject;
  dispose(): void;
  readonly metadata: ReadonlyJSONObject;
  setData(options: IRenderMime.IMimeModel.ISetDataOptions): void;
  toJSON(): nbformat.IMimeBundle;
  // (undocumented)
  readonly trusted: boolean;
}

// @public
export namespace AttachmentModel {
  export function getData(bundle: nbformat.IMimeBundle): JSONObject;
}

// @public
export const htmlRendererFactory: IRenderMime.IRendererFactory;

// @public
export interface IAttachmentModel extends IRenderMime.IMimeModel {
  readonly changed: ISignal<this, void>;
  dispose(): void;
  toJSON(): nbformat.IMimeBundle;
}

// @public
export namespace IAttachmentModel {
  export interface IOptions {
    value: nbformat.IMimeBundle;
  }
}

// @public
export const ILatexTypesetter: Token<IRenderMime.ILatexTypesetter>;

// @public (undocumented)
export interface ILatexTypesetter extends IRenderMime.ILatexTypesetter {}

// @public
export const imageRendererFactory: IRenderMime.IRendererFactory;

// @public
export interface IOutputModel extends IRenderMime.IMimeModel {
  readonly changed: ISignal<this, void>;
  dispose(): void;
  readonly executionCount: nbformat.ExecutionCount;
  toJSON(): nbformat.IOutput;
  trusted: boolean;
  readonly type: string;
}

// @public
export namespace IOutputModel {
  export interface IOptions {
    trusted?: boolean;
    value: nbformat.IOutput;
  }
}

// @public
export const IRenderMimeRegistry: Token<IRenderMimeRegistry>;

// @public (undocumented)
export interface IRenderMimeRegistry {
  addFactory(factory: IRenderMime.IRendererFactory, rank?: number): void;
  clone(options?: IRenderMimeRegistry.ICloneOptions): IRenderMimeRegistry;
  createModel(options?: MimeModel.IOptions): MimeModel;
  createRenderer(mimeType: string): IRenderMime.IRenderer;
  getFactory(mimeType: string): IRenderMime.IRendererFactory | undefined;
  getRank(mimeType: string): number | undefined;
  readonly latexTypesetter: IRenderMime.ILatexTypesetter | null;
  readonly linkHandler: IRenderMime.ILinkHandler | null;
  readonly mimeTypes: ReadonlyArray<string>;
  preferredMimeType(
    bundle: ReadonlyJSONObject,
    safe?: 'ensure' | 'prefer' | 'any'
  ): string | undefined;
  removeMimeType(mimeType: string): void;
  readonly resolver: IRenderMime.IResolver | null;
  readonly sanitizer: ISanitizer;
  setRank(mimeType: string, rank: number): void;
}

// @public (undocumented)
export namespace IRenderMimeRegistry {
  export interface ICloneOptions {
    latexTypesetter?: IRenderMime.ILatexTypesetter;
    linkHandler?: IRenderMime.ILinkHandler;
    resolver?: IRenderMime.IResolver;
    sanitizer?: IRenderMime.ISanitizer;
  }
}

// @public
export const javaScriptRendererFactory: IRenderMime.IRendererFactory;

// @public
export const latexRendererFactory: IRenderMime.IRendererFactory;

// @public
export const markdownRendererFactory: IRenderMime.IRendererFactory;

// @public
export class MimeModel implements IRenderMime.IMimeModel {
  constructor(options?: MimeModel.IOptions);
  readonly data: ReadonlyJSONObject;
  readonly metadata: ReadonlyJSONObject;
  setData(options: IRenderMime.IMimeModel.ISetDataOptions): void;
  readonly trusted: boolean;
}

// @public
export namespace MimeModel {
  export interface IOptions {
    callback?: (options: IRenderMime.IMimeModel.ISetDataOptions) => void;
    data?: ReadonlyJSONObject;
    metadata?: ReadonlyJSONObject;
    trusted?: boolean;
  }
}

// @public
export class OutputModel implements IOutputModel {
  constructor(options: IOutputModel.IOptions);
  readonly changed: ISignal<this, void>;
  readonly data: ReadonlyJSONObject;
  dispose(): void;
  readonly executionCount: nbformat.ExecutionCount;
  readonly metadata: ReadonlyJSONObject;
  setData(options: IRenderMime.IMimeModel.ISetDataOptions): void;
  toJSON(): nbformat.IOutput;
  readonly trusted: boolean;
  readonly type: string;
}

// @public
export namespace OutputModel {
  export function getData(output: nbformat.IOutput): JSONObject;
  export function getMetadata(output: nbformat.IOutput): JSONObject;
}

// @public
export function removeMath(
  text: string
): {
  text: string;
  math: string[];
};

// @public
export abstract class RenderedCommon extends Widget
  implements IRenderMime.IRenderer {
  constructor(options: IRenderMime.IRendererOptions);
  readonly latexTypesetter: IRenderMime.ILatexTypesetter;
  readonly linkHandler: IRenderMime.ILinkHandler | null;
  readonly mimeType: string;
  abstract render(model: IRenderMime.IMimeModel): Promise<void>;
  renderModel(model: IRenderMime.IMimeModel): Promise<void>;
  readonly resolver: IRenderMime.IResolver | null;
  readonly sanitizer: IRenderMime.ISanitizer;
  protected setFragment(fragment: string): void;
}

// @public
export class RenderedHTML extends RenderedHTMLCommon {
  constructor(options: IRenderMime.IRendererOptions);
  onAfterAttach(msg: Message): void;
  render(model: IRenderMime.IMimeModel): Promise<void>;
}

// @public
export abstract class RenderedHTMLCommon extends RenderedCommon {
  constructor(options: IRenderMime.IRendererOptions);
  // (undocumented)
  setFragment(fragment: string): void;
}

// @public
export class RenderedImage extends RenderedCommon {
  constructor(options: IRenderMime.IRendererOptions);
  render(model: IRenderMime.IMimeModel): Promise<void>;
}

// @public
export class RenderedJavaScript extends RenderedCommon {
  constructor(options: IRenderMime.IRendererOptions);
  render(model: IRenderMime.IMimeModel): Promise<void>;
}

// @public
export class RenderedLatex extends RenderedCommon {
  constructor(options: IRenderMime.IRendererOptions);
  onAfterAttach(msg: Message): void;
  render(model: IRenderMime.IMimeModel): Promise<void>;
}

// @public
export class RenderedMarkdown extends RenderedHTMLCommon {
  constructor(options: IRenderMime.IRendererOptions);
  onAfterAttach(msg: Message): void;
  render(model: IRenderMime.IMimeModel): Promise<void>;
}

// @public
export class RenderedSVG extends RenderedCommon {
  constructor(options: IRenderMime.IRendererOptions);
  onAfterAttach(msg: Message): void;
  render(model: IRenderMime.IMimeModel): Promise<void>;
}

// @public
export class RenderedText extends RenderedCommon {
  constructor(options: IRenderMime.IRendererOptions);
  render(model: IRenderMime.IMimeModel): Promise<void>;
}

// @public
export function renderHTML(options: renderHTML.IOptions): Promise<void>;

// @public
export namespace renderHTML {
  export interface IOptions {
    host: HTMLElement;
    latexTypesetter: IRenderMime.ILatexTypesetter | null;
    linkHandler: IRenderMime.ILinkHandler | null;
    resolver: IRenderMime.IResolver | null;
    sanitizer: ISanitizer;
    shouldTypeset: boolean;
    source: string;
    trusted: boolean;
  }
}

// @public
export function renderImage(options: renderImage.IRenderOptions): Promise<void>;

// @public
export namespace renderImage {
  export interface IRenderOptions {
    height?: number;
    host: HTMLElement;
    mimeType: string;
    needsBackground?: string;
    source: string;
    unconfined?: boolean;
    width?: number;
  }
}

// @public
export function renderLatex(options: renderLatex.IRenderOptions): Promise<void>;

// @public
export namespace renderLatex {
  export interface IRenderOptions {
    host: HTMLElement;
    latexTypesetter: IRenderMime.ILatexTypesetter | null;
    shouldTypeset: boolean;
    source: string;
  }
}

// @public
export function renderMarkdown(
  options: renderMarkdown.IRenderOptions
): Promise<void>;

// @public
export namespace renderMarkdown {
  export interface IRenderOptions {
    host: HTMLElement;
    latexTypesetter: IRenderMime.ILatexTypesetter | null;
    linkHandler: IRenderMime.ILinkHandler | null;
    resolver: IRenderMime.IResolver | null;
    sanitizer: ISanitizer;
    shouldTypeset: boolean;
    source: string;
    trusted: boolean;
  }
}

// @public
export class RenderMimeRegistry implements IRenderMimeRegistry {
  constructor(options?: RenderMimeRegistry.IOptions);
  addFactory(factory: IRenderMime.IRendererFactory, rank?: number): void;
  clone(options?: IRenderMimeRegistry.ICloneOptions): RenderMimeRegistry;
  createModel(options?: MimeModel.IOptions): MimeModel;
  createRenderer(mimeType: string): IRenderMime.IRenderer;
  getFactory(mimeType: string): IRenderMime.IRendererFactory | undefined;
  getRank(mimeType: string): number | undefined;
  readonly latexTypesetter: IRenderMime.ILatexTypesetter | null;
  readonly linkHandler: IRenderMime.ILinkHandler | null;
  readonly mimeTypes: ReadonlyArray<string>;
  preferredMimeType(
    bundle: ReadonlyJSONObject,
    safe?: 'ensure' | 'prefer' | 'any'
  ): string | undefined;
  removeMimeType(mimeType: string): void;
  readonly resolver: IRenderMime.IResolver | null;
  readonly sanitizer: ISanitizer;
  setRank(mimeType: string, rank: number): void;
}

// @public
export namespace RenderMimeRegistry {
  export interface IOptions {
    initialFactories?: ReadonlyArray<IRenderMime.IRendererFactory>;
    latexTypesetter?: IRenderMime.ILatexTypesetter;
    linkHandler?: IRenderMime.ILinkHandler;
    resolver?: IRenderMime.IResolver;
    sanitizer?: IRenderMime.ISanitizer;
  }
  export interface IUrlResolverOptions {
    contents: Contents.IManager;
    session: Session.ISession | IClientSession;
  }
  export class UrlResolver implements IRenderMime.IResolver {
    constructor(options: IUrlResolverOptions);
    getDownloadUrl(url: string): Promise<string>;
    isLocal(url: string): boolean;
    resolveUrl(url: string): Promise<string>;
  }
}

// @public
export function renderSVG(options: renderSVG.IRenderOptions): Promise<void>;

// @public
export namespace renderSVG {
  export interface IRenderOptions {
    host: HTMLElement;
    source: string;
    trusted: boolean;
    unconfined?: boolean;
  }
}

// @public
export function renderText(options: renderText.IRenderOptions): Promise<void>;

// @public
export namespace renderText {
  export interface IRenderOptions {
    host: HTMLElement;
    sanitizer: ISanitizer;
    source: string;
  }
}

// @public
export function replaceMath(text: string, math: string[]): string;

// @public
export const standardRendererFactories: ReadonlyArray<
  IRenderMime.IRendererFactory
>;

// @public
export const svgRendererFactory: IRenderMime.IRendererFactory;

// @public
export const textRendererFactory: IRenderMime.IRendererFactory;

export * from '@jupyterlab/rendermime-interfaces';

// (No @packageDocumentation comment for this package)
```
