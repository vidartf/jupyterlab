## API Report File for "@jupyterlab/coreutils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

````ts
import { CommandRegistry } from '@phosphor/commands';
import { IDisposable } from '@phosphor/disposable';
import { IObservableDisposable } from '@phosphor/disposable';
import { ISignal } from '@phosphor/signaling';
import { JSONObject } from '@phosphor/coreutils';
import { JSONValue } from '@phosphor/coreutils';
import { PromiseDelegate } from '@phosphor/coreutils';
import { ReadonlyJSONObject } from '@phosphor/coreutils';
import { ReadonlyJSONValue } from '@phosphor/coreutils';
import { Token } from '@phosphor/coreutils';

// @public
export class ActivityMonitor<Sender, Args> implements IDisposable {
  constructor(options: ActivityMonitor.IOptions<Sender, Args>);
  readonly activityStopped: ISignal<
    this,
    ActivityMonitor.IArguments<Sender, Args>
  >;
  dispose(): void;
  readonly isDisposed: boolean;
  timeout: number;
}

// @public
export namespace ActivityMonitor {
  export interface IArguments<Sender, Args> {
    args: Args;
    sender: Sender;
  }
  export interface IOptions<Sender, Args> {
    signal: ISignal<Sender, Args>;
    timeout?: number;
  }
}

// @public
export abstract class DataConnector<T, U = T, V = string>
  implements IDataConnector<T, U, V> {
  abstract fetch(id: V): Promise<T | undefined>;
  list(
    query?: any
  ): Promise<{
    ids: V[];
    values: T[];
  }>;
  remove(id: V): Promise<any>;
  save(id: V, value: U): Promise<any>;
}

// @public
export class Debouncer<T = any, U = any> extends RateLimiter<T, U> {
  invoke(): Promise<T>;
}

// @public
export class DefaultSchemaValidator implements ISchemaValidator {
  constructor();
  validateData(
    plugin: ISettingRegistry.IPlugin,
    populate?: boolean
  ): ISchemaValidator.IError[] | null;
}

// @public
export interface IChangedArgs<T, U extends string = string> {
  name: U;
  newValue: T;
  oldValue: T;
}

// @public
export interface IDataConnector<T, U = T, V = string> {
  fetch(id: V): Promise<T | undefined>;
  list(
    query?: any
  ): Promise<{
    ids: V[];
    values: T[];
  }>;
  remove(id: V): Promise<any>;
  save(id: V, value: U): Promise<any>;
}

// @public
export interface IObjectPool<T extends IObservableDisposable>
  extends IDisposable {
  readonly added: ISignal<this, T>;
  readonly current: T | null;
  readonly currentChanged: ISignal<this, T | null>;
  filter(fn: (obj: T) => boolean): T[];
  find(fn: (obj: T) => boolean): T | undefined;
  forEach(fn: (obj: T) => void): void;
  has(obj: T): boolean;
  readonly size: number;
  readonly updated: ISignal<this, T>;
}

// @public
export interface IPoll<T, U, V extends string> {
  readonly disposed: ISignal<this, void>;
  readonly frequency: IPoll.Frequency;
  readonly isDisposed: boolean;
  readonly name: string;
  readonly state: IPoll.State<T, U, V>;
  readonly tick: Promise<IPoll<T, U, V>>;
  readonly ticked: ISignal<IPoll<T, U, V>, IPoll.State<T, U, V>>;
}

// @public
export namespace IPoll {
  export type Frequency = {
    readonly backoff: boolean | number;
    readonly interval: number;
    readonly max: number;
  };
  export type Phase<T extends string> =
    | T
    | 'constructed'
    | 'disposed'
    | 'reconnected'
    | 'refreshed'
    | 'rejected'
    | 'resolved'
    | 'standby'
    | 'started'
    | 'stopped';
  export type State<T, U, V extends string> = {
    readonly interval: number;
    readonly payload: T | U | null;
    readonly phase: Phase<V>;
    readonly timestamp: number;
  };
}

// @public
export interface IRateLimiter<T = any, U = any> extends IDisposable {
  invoke(): Promise<T>;
  readonly limit: number;
  stop(): Promise<void>;
}

// @public
export interface IRestorable<T extends IObservableDisposable, U = any> {
  restore(options: IRestorable.IOptions<T>): Promise<U>;
  readonly restored: Promise<U>;
}

// @public
export namespace IRestorable {
  export interface IOptions<T extends IObservableDisposable>
    extends IRestorer.IOptions<T> {
    connector: IDataConnector<ReadonlyJSONValue>;
    registry: CommandRegistry;
  }
}

// @public
export interface IRestorer<
  T extends IRestorable<U> = IRestorable<IObservableDisposable>,
  U extends IObservableDisposable = IObservableDisposable,
  V = any
> {
  restore(restorable: T, options: IRestorable.IOptions<U>): Promise<V>;
  readonly restored: Promise<V>;
}

// @public
export namespace IRestorer {
  export interface IOptions<T extends IObservableDisposable> {
    args?: (obj: T) => ReadonlyJSONObject;
    command: string;
    name: (obj: T) => string;
    when?: Promise<any> | Array<Promise<any>>;
  }
}

// @public
export interface ISchemaValidator {
  validateData(
    plugin: ISettingRegistry.IPlugin,
    populate?: boolean
  ): ISchemaValidator.IError[] | null;
}

// @public
export namespace ISchemaValidator {
  export interface IError {
    dataPath: string;
    keyword: string;
    message: string;
    params?: ReadonlyJSONObject;
    schemaPath: string;
  }
}

// @public
export const ISettingRegistry: Token<ISettingRegistry>;

// @public
export interface ISettingRegistry {
  readonly connector: IDataConnector<ISettingRegistry.IPlugin, string, string>;
  get(
    plugin: string,
    key: string
  ): Promise<{
    composite: JSONValue;
    user: JSONValue;
  }>;
  load(plugin: string): Promise<ISettingRegistry.ISettings>;
  readonly pluginChanged: ISignal<this, string>;
  readonly plugins: {
    [name: string]: ISettingRegistry.IPlugin;
  };
  reload(plugin: string): Promise<ISettingRegistry.ISettings>;
  remove(plugin: string, key: string): Promise<void>;
  readonly schema: ISettingRegistry.ISchema;
  set(plugin: string, key: string, value: JSONValue): Promise<void>;
  transform(
    plugin: string,
    transforms: {
      [phase in ISettingRegistry.IPlugin.Phase]?: ISettingRegistry.IPlugin.Transform;
    }
  ): IDisposable;
  upload(plugin: string, raw: string): Promise<void>;
  readonly validator: ISchemaValidator;
}

// @public
export namespace ISettingRegistry {
  export interface IPlugin extends JSONObject {
    data: ISettingBundle;
    id: string;
    raw: string;
    schema: ISchema;
    version: string;
  }
  export namespace IPlugin {
    export type Phase = 'compose' | 'fetch';
    export type Transform = (plugin: IPlugin) => IPlugin;
  }
  export interface IProperty extends JSONObject {
    default?: any;
    description?: string;
    properties?: {
      [property: string]: IProperty;
    };
    title?: string;
    type?: Primitive | Primitive[];
  }
  export interface ISchema extends IProperty {
    'jupyter.lab.setting-deprecated'?: boolean;
    'jupyter.lab.setting-icon-class'?: string;
    'jupyter.lab.setting-icon-label'?: string;
    'jupyter.lab.shortcuts'?: IShortcut[];
    'jupyter.lab.transform'?: boolean;
    type: 'object';
  }
  export interface ISettingBundle extends JSONObject {
    composite: JSONObject;
    user: JSONObject;
  }
  export interface ISettings extends IDisposable {
    annotatedDefaults(): string;
    readonly changed: ISignal<this, void>;
    readonly composite: ReadonlyJSONObject;
    default(key: string): JSONValue | undefined;
    get(
      key: string
    ): {
      composite: ReadonlyJSONValue;
      user: ReadonlyJSONValue;
    };
    readonly id: string;
    // (undocumented)
    readonly plugin: ISettingRegistry.IPlugin;
    readonly raw: string;
    remove(key: string): Promise<void>;
    save(raw: string): Promise<void>;
    readonly schema: ISettingRegistry.ISchema;
    set(key: string, value: JSONValue): Promise<void>;
    readonly user: ReadonlyJSONObject;
    validate(raw: string): ISchemaValidator.IError[] | null;
    readonly version: string;
  }
  export interface IShortcut extends JSONObject {
    args?: JSONObject;
    command: string;
    disabled?: boolean;
    keys: string[];
    selector: string;
  }
  export type Primitive =
    | 'array'
    | 'boolean'
    | 'null'
    | 'number'
    | 'object'
    | 'string';
}

// @public
export const IStateDB: Token<IStateDB<ReadonlyJSONValue>>;

// @public
export interface IStateDB<T extends ReadonlyJSONValue = ReadonlyJSONValue>
  extends IDataConnector<T> {
  toJSON(): Promise<{
    [id: string]: T;
  }>;
}

// @public
export namespace MarkdownCodeBlocks {
  const // (undocumented)
    CODE_BLOCK_MARKER = '```';
  export function findMarkdownCodeBlocks(text: string): MarkdownCodeBlock[];
  export function isMarkdown(extension: string): boolean;
  // (undocumented)
  export class MarkdownCodeBlock {
    constructor(startLine: number);
    // (undocumented)
    code: string;
    // (undocumented)
    endLine: number;
    // (undocumented)
    startLine: number;
  }
}

// @public
export namespace nbformat {
  const MAJOR_VERSION: number;
  const MINOR_VERSION: number;
  export type CellType = 'code' | 'markdown' | 'raw';
  export type ExecutionCount = number | null;
  export interface IAttachments {
    // (undocumented)
    [key: string]: IMimeBundle;
  }
  export interface IBaseCell extends JSONObject {
    cell_type: string;
    metadata: Partial<ICellMetadata>;
    source: MultilineString;
  }
  export interface IBaseCellJupyterMetadata extends JSONObject {
    source_hidden: boolean;
  }
  export interface IBaseCellMetadata extends JSONObject {
    jupyter: Partial<IBaseCellJupyterMetadata>;
    name: string;
    tags: string[];
    trusted: boolean;
  }
  export interface IBaseOutput extends JSONObject {
    output_type: string;
  }
  export type ICell = IRawCell | IMarkdownCell | ICodeCell | IUnrecognizedCell;
  export type ICellMetadata =
    | IBaseCellMetadata
    | IRawCellMetadata
    | ICodeCellMetadata;
  export interface ICodeCell extends IBaseCell {
    cell_type: 'code';
    execution_count: ExecutionCount;
    metadata: Partial<ICodeCellMetadata>;
    outputs: IOutput[];
  }
  export interface ICodeCellJupyterMetadata extends IBaseCellJupyterMetadata {
    outputs_hidden: boolean;
  }
  export interface ICodeCellMetadata extends IBaseCellMetadata {
    collapsed: boolean;
    jupyter: Partial<ICodeCellJupyterMetadata>;
    scrolled: boolean | 'auto';
  }
  export interface IDisplayData extends IBaseOutput {
    data: IMimeBundle;
    metadata: OutputMetadata;
    output_type: 'display_data';
  }
  export interface IDisplayUpdate extends IBaseOutput {
    data: IMimeBundle;
    metadata: OutputMetadata;
    output_type: 'update_display_data';
  }
  export interface IError extends IBaseOutput {
    ename: string;
    evalue: string;
    output_type: 'error';
    traceback: string[];
  }
  export interface IExecuteResult extends IBaseOutput {
    data: IMimeBundle;
    execution_count: ExecutionCount;
    metadata: OutputMetadata;
    output_type: 'execute_result';
  }
  export interface IKernelspecMetadata extends JSONObject {
    // (undocumented)
    display_name: string;
    // (undocumented)
    name: string;
  }
  export interface ILanguageInfoMetadata extends JSONObject {
    // (undocumented)
    codemirror_mode?: string | JSONObject;
    // (undocumented)
    file_extension?: string;
    // (undocumented)
    mimetype?: string;
    // (undocumented)
    name: string;
    // (undocumented)
    pygments_lexer?: string;
  }
  export interface IMarkdownCell extends IBaseCell {
    attachments?: IAttachments;
    cell_type: 'markdown';
  }
  export interface IMimeBundle extends JSONObject {
    // (undocumented)
    [key: string]: MultilineString | JSONObject;
  }
  export interface INotebookContent extends JSONObject {
    // (undocumented)
    cells: ICell[];
    // (undocumented)
    metadata: INotebookMetadata;
    // (undocumented)
    nbformat: number;
    // (undocumented)
    nbformat_minor: number;
  }
  export interface INotebookMetadata extends JSONObject {
    // (undocumented)
    kernelspec?: IKernelspecMetadata;
    // (undocumented)
    language_info?: ILanguageInfoMetadata;
    // (undocumented)
    orig_nbformat: number;
  }
  export type IOutput =
    | IUnrecognizedOutput
    | IExecuteResult
    | IDisplayData
    | IStream
    | IError;
  export interface IRawCell extends IBaseCell {
    attachments?: IAttachments;
    cell_type: 'raw';
    metadata: Partial<IRawCellMetadata>;
  }
  export interface IRawCellMetadata extends IBaseCellMetadata {
    format: string;
  }
  export function isCode(cell: ICell): cell is ICodeCell;
  export function isDisplayData(output: IOutput): output is IDisplayData;
  export function isDisplayUpdate(output: IOutput): output is IDisplayUpdate;
  export function isError(output: IOutput): output is IError;
  export function isExecuteResult(output: IOutput): output is IExecuteResult;
  export function isMarkdown(cell: ICell): cell is IMarkdownCell;
  export function isRaw(cell: ICell): cell is IRawCell;
  export function isStream(output: IOutput): output is IStream;
  export interface IStream extends IBaseOutput {
    name: StreamType;
    output_type: 'stream';
    text: MultilineString;
  }
  export interface IUnrecognizedCell extends IBaseCell {}
  export interface IUnrecognizedOutput extends IBaseOutput {}
  export type MultilineString = string | string[];
  export type OutputMetadata = JSONObject;
  export type OutputType =
    | 'execute_result'
    | 'display_data'
    | 'stream'
    | 'error'
    | 'update_display_data';
  export type StreamType = 'stdout' | 'stderr';
  export function validateMimeValue(
    type: string,
    value: MultilineString | JSONObject
  ): boolean;
}

// @public
export namespace PageConfig {
  export namespace Extension {
    const deferred: {
      raw: string;
      rule: RegExp;
    }[];
    const disabled: {
      raw: string;
      rule: RegExp;
    }[];
    export function isDeferred(id: string): boolean;
    export function isDisabled(id: string): boolean;
  }
  export function getBaseUrl(): string;
  export function getNBConvertURL({
    path,
    format,
    download
  }: {
    path: string;
    format: string;
    download: boolean;
  }): string;
  export function getNotebookVersion(): [number, number, number];
  export function getOption(name: string): string;
  export function getToken(): string;
  export function getTreeUrl(): string;
  export function getWsUrl(baseUrl?: string): string;
  export function setOption(name: string, value: string): string;
}

// @public
export namespace PathExt {
  export function basename(path: string, ext?: string): string;
  export function dirname(path: string): string;
  export function extname(path: string): string;
  export function join(...paths: string[]): string;
  export function normalize(path: string): string;
  export function normalizeExtension(extension: string): string;
  export function relative(from: string, to: string): string;
  export function removeSlash(path: string): string;
  export function resolve(...parts: string[]): string;
  export function stem(path: string): string;
}

// @public
export class Poll<T = any, U = any, V extends string = 'standby'>
  implements IObservableDisposable, IPoll<T, U, V> {
  constructor(options: Poll.IOptions<T, U, V>);
  dispose(): void;
  readonly disposed: ISignal<this, void>;
  frequency: IPoll.Frequency;
  readonly isDisposed: boolean;
  readonly name: string;
  refresh(): Promise<void>;
  schedule(
    next?: Partial<
      IPoll.State<T, U, V> & {
        cancel: (last: IPoll.State<T, U, V>) => boolean;
      }
    >
  ): Promise<void>;
  standby: Poll.Standby | (() => boolean | Poll.Standby);
  start(): Promise<void>;
  readonly state: IPoll.State<T, U, V>;
  stop(): Promise<void>;
  readonly tick: Promise<this>;
  readonly ticked: ISignal<this, IPoll.State<T, U, V>>;
}

// @public
export namespace Poll {
  export type Factory<T, U, V extends string> = (
    state: IPoll.State<T, U, V>
  ) => Promise<T>;
  export interface IOptions<T, U, V extends string> {
    auto?: boolean;
    factory: Factory<T, U, V>;
    frequency?: Partial<IPoll.Frequency>;
    name?: string;
    standby?: Standby | (() => boolean | Standby);
  }
  export type Standby = 'never' | 'when-hidden';
  const IMMEDIATE = 0;
  const MAX_INTERVAL = 2147483647;
  const NEVER: number;
}

// @public
export abstract class RateLimiter<T, U> implements IRateLimiter<T, U> {
  constructor(fn: () => T | Promise<T>, limit?: number);
  dispose(): void;
  abstract invoke(): Promise<T>;
  readonly isDisposed: boolean;
  readonly limit: number;
  protected payload: PromiseDelegate<T> | null;
  protected poll: Poll<T, U, 'invoked'>;
  stop(): Promise<void>;
}

// @public
export class RestorablePool<
  T extends IObservableDisposable = IObservableDisposable
> implements IObjectPool<T>, IRestorable<T> {
  constructor(options: RestorablePool.IOptions);
  add(obj: T): Promise<void>;
  readonly added: ISignal<this, T>;
  current: T | null;
  readonly currentChanged: ISignal<this, T | null>;
  dispose(): void;
  filter(fn: (obj: T) => boolean): T[];
  find(fn: (obj: T) => boolean): T | undefined;
  forEach(fn: (obj: T) => void): void;
  has(obj: T): boolean;
  inject(obj: T): Promise<void>;
  readonly isDisposed: boolean;
  readonly namespace: string;
  restore(options: IRestorable.IOptions<T>): Promise<any>;
  readonly restored: Promise<void>;
  save(obj: T): Promise<void>;
  readonly size: number;
  readonly updated: ISignal<this, T>;
}

// @public
export namespace RestorablePool {
  export interface IOptions {
    namespace: string;
  }
}

// @public
export class SettingRegistry implements ISettingRegistry {
  constructor(options: SettingRegistry.IOptions);
  readonly connector: IDataConnector<ISettingRegistry.IPlugin, string, string>;
  get(
    plugin: string,
    key: string
  ): Promise<{
    composite: JSONValue;
    user: JSONValue;
  }>;
  load(plugin: string): Promise<ISettingRegistry.ISettings>;
  readonly pluginChanged: ISignal<this, string>;
  readonly plugins: {
    [name: string]: ISettingRegistry.IPlugin;
  };
  reload(plugin: string): Promise<ISettingRegistry.ISettings>;
  remove(plugin: string, key: string): Promise<void>;
  readonly schema: ISettingRegistry.ISchema;
  set(plugin: string, key: string, value: JSONValue): Promise<void>;
  transform(
    plugin: string,
    transforms: {
      [phase in ISettingRegistry.IPlugin.Phase]?: ISettingRegistry.IPlugin.Transform;
    }
  ): IDisposable;
  upload(plugin: string, raw: string): Promise<void>;
  readonly validator: ISchemaValidator;
}

// @public
export namespace SettingRegistry {
  export interface IOptions {
    connector: IDataConnector<ISettingRegistry.IPlugin, string>;
    plugins?: ISettingRegistry.IPlugin[];
    timeout?: number;
    validator?: ISchemaValidator;
  }
  export function reconcileShortcuts(
    defaults: ISettingRegistry.IShortcut[],
    user: ISettingRegistry.IShortcut[]
  ): ISettingRegistry.IShortcut[];
}

// @public
export class Settings implements ISettingRegistry.ISettings {
  constructor(options: Settings.IOptions);
  annotatedDefaults(): string;
  readonly changed: ISignal<this, void>;
  readonly composite: ReadonlyJSONObject;
  default(key: string): JSONValue | undefined;
  dispose(): void;
  get(
    key: string
  ): {
    composite: ReadonlyJSONValue;
    user: ReadonlyJSONValue;
  };
  readonly id: string;
  readonly isDisposed: boolean;
  // (undocumented)
  readonly plugin: ISettingRegistry.IPlugin;
  readonly raw: string;
  readonly registry: ISettingRegistry;
  remove(key: string): Promise<void>;
  save(raw: string): Promise<void>;
  readonly schema: ISettingRegistry.ISchema;
  set(key: string, value: JSONValue): Promise<void>;
  readonly user: ReadonlyJSONObject;
  validate(raw: string): ISchemaValidator.IError[] | null;
  readonly version: string;
}

// @public
export namespace Settings {
  export interface IOptions {
    plugin: ISettingRegistry.IPlugin;
    registry: ISettingRegistry;
  }
}

// @public
export class StateDB<T extends ReadonlyJSONValue = ReadonlyJSONValue>
  implements IStateDB<T> {
  constructor(options?: StateDB.IOptions);
  readonly changed: ISignal<this, StateDB.Change>;
  clear(): Promise<void>;
  fetch(id: string): Promise<T>;
  list(
    namespace: string
  ): Promise<{
    ids: string[];
    values: T[];
  }>;
  remove(id: string): Promise<void>;
  save(id: string, value: T): Promise<void>;
  toJSON(): Promise<{
    readonly [id: string]: T;
  }>;
}

// @public
export namespace StateDB {
  export type Change = {
    id: string | null;
    type: 'clear' | 'remove' | 'save';
  };
  export class Connector implements IDataConnector<string> {
    fetch(id: string): Promise<string>;
    list(
      query?: string
    ): Promise<{
      ids: string[];
      values: string[];
    }>;
    remove(id: string): Promise<void>;
    save(id: string, value: string): Promise<void>;
  }
  export type DataTransform = {
    type: 'cancel' | 'clear' | 'merge' | 'overwrite';
    contents: ReadonlyJSONObject | null;
  };
  export interface IOptions {
    connector?: IDataConnector<string>;
    transform?: Promise<DataTransform>;
  }
}

// @public
export namespace Text {
  export function camelCase(str: string, upper?: boolean): string;
  export function charIndexToJsIndex(charIdx: number, text: string): number;
  export function jsIndexToCharIndex(jsIdx: number, text: string): number;
  export function titleCase(str: string): string;
}

// @public
export class Throttler<T = any, U = any> extends RateLimiter<T, U> {
  invoke(): Promise<T>;
}

// @public
export namespace Time {
  export function format(value: string | Date, format?: string): string;
  export function formatHuman(value: string | Date): string;
}

// @public
export namespace URLExt {
  export function encodeParts(url: string): string;
  export function isLocal(url: string): boolean;
  export interface IUrl {
    hash?: string;
    host?: string;
    hostname?: string;
    href?: string;
    pathname?: string;
    port?: string;
    protocol?: string;
    search?: string;
  }
  export function join(...parts: string[]): string;
  export function normalize(url: string): string;
  export function objectToQueryString(value: JSONObject): string;
  export function parse(url: string): IUrl;
  export function queryStringToObject(
    value: string
  ): {
    [key: string]: string;
  };
}

// (No @packageDocumentation comment for this package)
````
