## API Report File for "@jupyterlab/apputils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { CommandPalette } from '@phosphor/widgets';
import { CommandRegistry } from '@phosphor/commands';
import { ElementDataset } from '@phosphor/virtualdom';
import { IChangedArgs } from '@jupyterlab/coreutils';
import { IDisposable } from '@phosphor/disposable';
import { IIterator } from '@phosphor/algorithm';
import { IRestorable } from '@jupyterlab/coreutils';
import { ISettingRegistry } from '@jupyterlab/coreutils';
import { ISignal } from '@phosphor/signaling';
import { IterableOrArrayLike } from '@phosphor/algorithm';
import { JSONObject } from '@phosphor/coreutils';
import { Kernel } from '@jupyterlab/services';
import { KernelMessage } from '@jupyterlab/services';
import { Message } from '@phosphor/messaging';
import { MimeData } from '@phosphor/coreutils';
import * as React from 'react';
import { ReadonlyJSONObject } from '@phosphor/coreutils';
import { Session } from '@jupyterlab/services';
import { Signal } from '@phosphor/signaling';
import { Token } from '@phosphor/coreutils';
import { Widget } from '@phosphor/widgets';

// @public (undocumented)
export function addCommandToolbarButtonClass(w: Widget): Widget;

// @public
export function addToolbarButtonClass(w: Widget): Widget;

// @public
export class ClientSession implements IClientSession {
  constructor(options: ClientSession.IOptions);
  changeKernel(
    options: Partial<Kernel.IModel>
  ): Promise<Kernel.IKernelConnection>;
  dispose(): void;
  initialize(): Promise<void>;
  readonly iopubMessage: ISignal<this, KernelMessage.IIOPubMessage>;
  readonly isDisposed: boolean;
  readonly isReady: boolean;
  readonly kernel: Kernel.IKernelConnection | null;
  readonly kernelChanged: ISignal<this, Session.IKernelChangedArgs>;
  readonly kernelDisplayName: string;
  kernelPreference: IClientSession.IKernelPreference;
  readonly manager: Session.IManager;
  readonly name: string;
  readonly path: string;
  readonly propertyChanged: ISignal<this, 'path' | 'name' | 'type'>;
  readonly ready: Promise<void>;
  restart(): Promise<boolean>;
  selectKernel(): Promise<void>;
  setName(name: string): Promise<void>;
  setPath(path: string): Promise<void>;
  setType(type: string): Promise<void>;
  shutdown(): Promise<void>;
  readonly status: Kernel.Status;
  readonly statusChanged: ISignal<this, Kernel.Status>;
  readonly terminated: ISignal<this, void>;
  readonly type: string;
  readonly unhandledMessage: ISignal<this, KernelMessage.IMessage>;
}

// @public
export namespace ClientSession {
  export function getDefaultKernel(options: IKernelSearch): string | null;
  export interface IKernelSearch {
    preference: IClientSession.IKernelPreference;
    sessions?: IterableOrArrayLike<Session.IModel>;
    specs: Kernel.ISpecModels | null;
  }
  export interface IOptions {
    kernelPreference?: IClientSession.IKernelPreference;
    manager: Session.IManager;
    name?: string;
    path?: string;
    setBusy?: () => IDisposable;
    type?: string;
  }
  export function populateKernelSelect(
    node: HTMLSelectElement,
    options: IKernelSearch
  ): void;
  export function restartKernel(
    kernel: Kernel.IKernelConnection
  ): Promise<boolean>;
}

// @public
export namespace Clipboard {
  export function copyToSystem(clipboardData: ClipboardData): void;
  export function generateEvent(node: HTMLElement, type?: 'copy' | 'cut'): void;
  export function getInstance(): MimeData;
  export function setInstance(value: MimeData): void;
}

// @public (undocumented)
export type ClipboardData = string | MimeData;

// @public
export class Collapse<T extends Widget = Widget> extends Widget {
  constructor(options: Collapse.IOptions<T>);
  readonly collapseChanged: ISignal<Collapse, void>;
  collapsed: boolean;
  dispose(): void;
  handleEvent(event: Event): void;
  // (undocumented)
  protected onAfterAttach(msg: Message): void;
  // (undocumented)
  protected onBeforeDetach(msg: Message): void;
  toggle(): void;
  widget: T;
}

// @public (undocumented)
export namespace Collapse {
  // (undocumented)
  export interface IOptions<T extends Widget = Widget> extends Widget.IOptions {
    // (undocumented)
    collapsed?: boolean;
    // (undocumented)
    widget: T;
  }
}

// @public
export class CommandLinker implements IDisposable {
  constructor(options: CommandLinker.IOptions);
  connectNode(
    node: HTMLElement,
    command: string,
    args?: JSONObject
  ): HTMLElement;
  disconnectNode(node: HTMLElement): HTMLElement;
  dispose(): void;
  handleEvent(event: Event): void;
  readonly isDisposed: boolean;
  populateVNodeDataset(command: string, args?: JSONObject): ElementDataset;
}

// @public
export namespace CommandLinker {
  export interface IOptions {
    commands: CommandRegistry;
  }
}

// @public
export class CommandToolbarButton extends ReactWidget {
  constructor(props: CommandToolbarButtonComponent.IProps);
  // (undocumented)
  render(): JSX.Element;
}

// @public
export function CommandToolbarButtonComponent(
  props: CommandToolbarButtonComponent.IProps
): JSX.Element;

// @public
export namespace CommandToolbarButtonComponent {
  export interface IProps {
    // (undocumented)
    args?: ReadonlyJSONObject;
    // (undocumented)
    commands: CommandRegistry;
    // (undocumented)
    id: string;
  }
}

// @public
export const defaultSanitizer: ISanitizer;

// @public
export class Dialog<T> extends Widget {
  constructor(options?: Partial<Dialog.IOptions<T>>);
  dispose(): void;
  protected _evtClick(event: MouseEvent): void;
  protected _evtFocus(event: FocusEvent): void;
  protected _evtKeydown(event: KeyboardEvent): void;
  handleEvent(event: Event): void;
  launch(): Promise<Dialog.IResult<T>>;
  protected onAfterAttach(msg: Message): void;
  protected onAfterDetach(msg: Message): void;
  protected onCloseRequest(msg: Message): void;
  reject(): void;
  resolve(index?: number): void;
}

// @public
export namespace Dialog {
  export type Body<T> = IBodyWidget<T> | React.ReactElement<any> | string;
  export function cancelButton(options?: Partial<IButton>): Readonly<IButton>;
  export function createButton(value: Partial<IButton>): Readonly<IButton>;
  export function flush(): void;
  export type Header = React.ReactElement<any> | string;
  export interface IBodyWidget<T = string> extends Widget {
    getValue?(): T;
  }
  export interface IButton {
    accept: boolean;
    caption: string;
    className: string;
    displayType: 'default' | 'warn';
    iconClass: string;
    iconLabel: string;
    label: string;
  }
  export interface IOptions<T> {
    body: Body<T>;
    buttons: ReadonlyArray<IButton>;
    defaultButton: number;
    focusNodeSelector: string;
    host: HTMLElement;
    renderer: IRenderer;
    title: Header;
  }
  export interface IRenderer {
    createBody(body: Body<any>): Widget;
    createButtonNode(button: IButton): HTMLElement;
    createFooter(buttons: ReadonlyArray<HTMLElement>): Widget;
    createHeader(title: Header): Widget;
  }
  export interface IResult<T> {
    button: IButton;
    value: T | null;
  }
  export function okButton(options?: Partial<IButton>): Readonly<IButton>;
  export class Renderer {
    createBody(value: Body<any>): Widget;
    createButtonNode(button: IButton): HTMLElement;
    createFooter(buttons: ReadonlyArray<HTMLElement>): Widget;
    createHeader(title: Header): Widget;
    createIconClass(data: IButton): string;
    createItemClass(data: IButton): string;
    renderIcon(data: IButton): HTMLElement;
    renderLabel(data: IButton): HTMLElement;
  }
  export function warnButton(options?: Partial<IButton>): Readonly<IButton>;
  const defaultRenderer: Renderer;
  const tracker: WidgetTracker<Dialog<any>>;
}

// @public
export namespace DOMUtils {
  export function createDomID(): string;
  export function findElement(
    parent: HTMLElement,
    className: string
  ): HTMLElement;
  export function findElements(
    parent: HTMLElement,
    className: string
  ): HTMLCollectionOf<HTMLElement>;
  export function hitTestNodes(
    nodes: HTMLElement[] | HTMLCollection,
    x: number,
    y: number
  ): number;
}

// @public
export namespace HoverBox {
  export interface IOptions {
    anchor: ClientRect;
    host: HTMLElement;
    maxHeight: number;
    minHeight: number;
    node: HTMLElement;
    offset?: {
      horizontal?: number;
      vertical?: {
        above?: number;
        below?: number;
      };
    };
    privilege?: 'above' | 'below' | 'forceAbove' | 'forceBelow';
    style?: CSSStyleDeclaration;
  }
  export function setGeometry(options: IOptions): void;
}

// @public
export interface IClientSession extends IDisposable {
  changeKernel(
    options: Partial<Kernel.IModel>
  ): Promise<Kernel.IKernelConnection>;
  readonly iopubMessage: ISignal<this, KernelMessage.IMessage>;
  readonly isReady: boolean;
  readonly kernel: Kernel.IKernelConnection | null;
  readonly kernelChanged: ISignal<this, Session.IKernelChangedArgs>;
  readonly kernelDisplayName: string;
  kernelPreference: IClientSession.IKernelPreference;
  readonly name: string;
  readonly path: string;
  readonly propertyChanged: ISignal<this, 'path' | 'name' | 'type'>;
  readonly ready: Promise<void>;
  restart(): Promise<boolean>;
  selectKernel(): Promise<void>;
  setName(name: string): Promise<void>;
  setPath(path: string): Promise<void>;
  setType(type: string): Promise<void>;
  shutdown(): Promise<void>;
  readonly status: Kernel.Status;
  readonly statusChanged: ISignal<this, Kernel.Status>;
  readonly terminated: ISignal<this, void>;
  readonly type: string;
  readonly unhandledMessage: ISignal<this, KernelMessage.IMessage>;
}

// @public
export namespace IClientSession {
  export interface IKernelPreference {
    readonly autoStartDefault?: boolean;
    readonly canStart?: boolean;
    readonly id?: string;
    readonly language?: string;
    readonly name?: string;
    readonly shouldStart?: boolean;
    readonly shutdownOnClose?: boolean;
  }
}

// @public
export const ICommandPalette: Token<ICommandPalette>;

// @public
export interface ICommandPalette {
  activate(): void;
  addItem(options: IPaletteItem): IDisposable;
  placeholder: string;
}

// @public
export class IFrame extends Widget {
  constructor(options?: IFrame.IOptions);
  referrerPolicy: IFrame.ReferrerPolicy;
  sandbox: IFrame.SandboxExceptions[];
  url: string;
}

// @public
export namespace IFrame {
  export interface IOptions {
    referrerPolicy?: ReferrerPolicy;
    sandbox?: SandboxExceptions[];
  }
  export type ReferrerPolicy =
    | 'no-referrer'
    | 'no-referrer-when-downgrade'
    | 'origin'
    | 'origin-when-cross-origin'
    | 'same-origin'
    | 'strict-origin'
    | 'strict-origin-when-cross-origin'
    | 'unsafe-url';
  export type SandboxExceptions =
    | 'allow-forms'
    | 'allow-modals'
    | 'allow-orientation-lock'
    | 'allow-pointer-lock'
    | 'allow-popups'
    | 'popups-to-escape-sandbox'
    | 'allow-presentation'
    | 'allow-same-origin'
    | 'allow-scripts'
    | 'allow-storage-access-by-user-activation'
    | 'allow-top-navigation'
    | 'allow-top-navigation-by-user-activation';
}

// @public
export namespace InputDialog {
  export function getBoolean(
    options: IBooleanOptions
  ): Promise<Dialog.IResult<boolean>>;
  export function getItem(
    options: IItemOptions
  ): Promise<Dialog.IResult<string>>;
  export function getNumber(
    options: INumberOptions
  ): Promise<Dialog.IResult<number>>;
  export function getText(
    options: ITextOptions
  ): Promise<Dialog.IResult<string>>;
  export interface IBooleanOptions extends IOptions {
    value?: boolean;
  }
  export interface IItemOptions extends IOptions {
    current?: number | string;
    editable?: boolean;
    items: Array<string>;
    placeholder?: string;
  }
  export interface INumberOptions extends IOptions {
    value?: number;
  }
  export interface IOptions {
    cancelLabel?: string;
    host?: HTMLElement;
    label?: string;
    okLabel?: string;
    renderer?: Dialog.IRenderer;
    title: Dialog.Header;
  }
  export interface ITextOptions extends IOptions {
    placeholder?: string;
    text?: string;
  }
}

// @public
export interface IPaletteItem extends CommandPalette.IItemOptions {}

// @public (undocumented)
export interface ISanitizer {
  sanitize(dirty: string, options?: ISanitizer.IOptions): string;
}

// @public
export namespace ISanitizer {
  export interface IOptions {
    allowedAttributes?: {
      [key: string]: string[];
    };
    allowedStyles?: {
      [key: string]: {
        [key: string]: RegExp[];
      };
    };
    allowedTags?: string[];
  }
}

// @public
export const ISplashScreen: Token<ISplashScreen>;

// @public
export interface ISplashScreen {
  show(light?: boolean): IDisposable;
}

// @public
export const IThemeManager: Token<IThemeManager>;

// @public
export interface IThemeManager {
  isLight(name: string): boolean;
  loadCSS(path: string): Promise<void>;
  register(theme: IThemeManager.ITheme): IDisposable;
  setTheme(name: string): Promise<void>;
  readonly theme: string | null;
  readonly themeChanged: ISignal<this, IChangedArgs<string>>;
  readonly themes: ReadonlyArray<string>;
  themeScrollbars(name: string): boolean;
}

// @public
export namespace IThemeManager {
  export interface ITheme {
    isLight: boolean;
    load(): Promise<void>;
    name: string;
    themeScrollbars?: boolean;
    unload(): Promise<void>;
  }
}

// @public
export interface IUseSignalProps<SENDER, ARGS> {
  children: (sender?: SENDER, args?: ARGS) => React.ReactNode;
  initialArgs?: ARGS;
  initialSender?: SENDER;
  shouldUpdate?: (sender: SENDER, args: ARGS) => boolean;
  signal: ISignal<SENDER, ARGS>;
}

// @public
export interface IUseSignalState<SENDER, ARGS> {
  // (undocumented)
  value: [SENDER?, ARGS?];
}

// @public
export interface IWidgetTracker<T extends Widget = Widget> extends IDisposable {
  readonly currentChanged: ISignal<this, T | null>;
  readonly currentWidget: T | null;
  filter(fn: (obj: T) => boolean): T[];
  find(fn: (obj: T) => boolean): T | undefined;
  forEach(fn: (obj: T) => void): void;
  has(obj: Widget): boolean;
  inject(obj: T): void;
  readonly restored: Promise<void>;
  readonly size: number;
  readonly widgetAdded: ISignal<this, T>;
  readonly widgetUpdated: ISignal<this, T>;
}

// @public
export const IWindowResolver: Token<IWindowResolver>;

// @public
export interface IWindowResolver {
  readonly name: string;
}

// @public
export class MainAreaWidget<T extends Widget = Widget> extends Widget
  implements Printing.IPrintable {
  [Printing.symbol](): Printing.OptionalAsyncThunk;
  constructor(options: MainAreaWidget.IOptions<T>);
  readonly content: T;
  readonly isRevealed: boolean;
  protected onActivateRequest(msg: Message): void;
  protected onCloseRequest(msg: Message): void;
  protected onUpdateRequest(msg: Message): void;
  readonly revealed: Promise<void>;
  readonly toolbar: Toolbar;
}

// @public
export namespace MainAreaWidget {
  export interface IOptions<T extends Widget = Widget> extends Widget.IOptions {
    content: T;
    reveal?: Promise<any>;
    toolbar?: Toolbar;
  }
  export interface IOptionsOptionalContent<T extends Widget = Widget>
    extends Widget.IOptions {
    content?: T;
    reveal?: Promise<any>;
    toolbar?: Toolbar;
  }
}

// @public (undocumented)
export namespace Printing {
  export function getPrintFunction(val: unknown): OptionalAsyncThunk;
  const symbol: unique symbol;
  export interface IPrintable {
    [symbol]: () => OptionalAsyncThunk;
  }
  export function isPrintable(a: unknown): a is IPrintable;
  export type OptionalAsyncThunk = () => Promise<void> | null;
  export function printURL(url: string): Promise<void>;
  export function printWidget(widget: Widget): Promise<void>;
}

// @public
export abstract class ReactWidget extends Widget {
  // Warning: (ae-forgotten-export) The symbol "ReactRenderElement" needs to be exported by the entry point index.d.ts
  static create(element: ReactRenderElement): ReactWidget;
  protected onAfterAttach(msg: Message): void;
  protected onBeforeDetach(msg: Message): void;
  protected onUpdateRequest(msg: Message): void;
  protected abstract render(): ReactRenderElement;
  // (undocumented)
  renderPromise?: Promise<void>;
}

// @public
export function showDialog<T>(
  options?: Partial<Dialog.IOptions<T>>
): Promise<Dialog.IResult<T>>;

// @public
export function showErrorMessage(
  title: string,
  error: any,
  buttons?: ReadonlyArray<Dialog.IButton>
): Promise<void>;

// @public
export class Spinner extends Widget {
  constructor();
  protected onActivateRequest(msg: Message): void;
}

// @public
export namespace Styling {
  export function styleNode(node: HTMLElement, className?: string): void;
  export function styleNodeByTag(
    node: HTMLElement,
    tagName: string,
    className?: string
  ): void;
  export function wrapSelect(node: HTMLSelectElement): HTMLElement;
}

// @public
export class ThemeManager implements IThemeManager {
  constructor(options: ThemeManager.IOptions);
  decrFontSize(key: string): Promise<void>;
  getCSS(key: string): string;
  incrFontSize(key: string): Promise<void>;
  isLight(name: string): boolean;
  isToggledThemeScrollbars(): boolean;
  loadCSS(path: string): Promise<void>;
  loadCSSOverrides(): void;
  register(theme: IThemeManager.ITheme): IDisposable;
  setCSSOverride(key: string, value: string): Promise<void>;
  setTheme(name: string): Promise<void>;
  readonly theme: string | null;
  readonly themeChanged: ISignal<this, IChangedArgs<string>>;
  readonly themes: ReadonlyArray<string>;
  themeScrollbars(name: string): boolean;
  toggleThemeScrollbars(): Promise<void>;
  validateCSS(key: string, val: string): boolean;
}

// @public (undocumented)
export namespace ThemeManager {
  export interface IOptions {
    host: Widget;
    key: string;
    settings: ISettingRegistry;
    splash?: ISplashScreen;
    url: string;
  }
}

// @public
export class Toolbar<T extends Widget = Widget> extends Widget {
  constructor();
  addItem(name: string, widget: T): boolean;
  protected handleClick(event: Event): void;
  handleEvent(event: Event): void;
  insertAfter(at: string, name: string, widget: T): boolean;
  insertBefore(at: string, name: string, widget: T): boolean;
  insertItem(index: number, name: string, widget: T): boolean;
  names(): IIterator<string>;
  protected onAfterAttach(msg: Message): void;
  protected onBeforeDetach(msg: Message): void;
}

// @public
export namespace Toolbar {
  export function createInterruptButton(session: IClientSession): Widget;
  export function createKernelNameItem(session: IClientSession): Widget;
  export function createKernelStatusItem(session: IClientSession): Widget;
  export function createRestartButton(session: IClientSession): Widget;
  export function createSpacerItem(): Widget;
}

// @public
export class ToolbarButton extends ReactWidget {
  constructor(props?: ToolbarButtonComponent.IProps);
  // (undocumented)
  render(): JSX.Element;
}

// @public
export function ToolbarButtonComponent(
  props: ToolbarButtonComponent.IProps
): JSX.Element;

// @public
export namespace ToolbarButtonComponent {
  export interface IProps {
    // (undocumented)
    className?: string;
    // (undocumented)
    enabled?: boolean;
    // (undocumented)
    iconClassName?: string;
    // (undocumented)
    iconLabel?: string;
    // (undocumented)
    label?: string;
    // (undocumented)
    onClick?: () => void;
    // (undocumented)
    tooltip?: string;
  }
}

// @public
export class UseSignal<SENDER, ARGS> extends React.Component<
  IUseSignalProps<SENDER, ARGS>,
  IUseSignalState<SENDER, ARGS>
> {
  constructor(props: IUseSignalProps<SENDER, ARGS>);
  // (undocumented)
  componentDidMount(): void;
  // (undocumented)
  componentWillUnmount(): void;
  // (undocumented)
  render(): React.ReactNode;
}

// @public
export class VDomModel implements VDomRenderer.IModel {
  dispose(): void;
  readonly isDisposed: boolean;
  readonly stateChanged: Signal<this, void>;
}

// @public
export abstract class VDomRenderer<
  T extends VDomRenderer.IModel | null
> extends ReactWidget {
  dispose(): void;
  model: T | null;
  readonly modelChanged: ISignal<this, void>;
}

// @public
export namespace VDomRenderer {
  export interface IModel extends IDisposable {
    readonly stateChanged: ISignal<this, void>;
  }
}

// @public
export class WidgetTracker<T extends Widget = Widget>
  implements IWidgetTracker<T>, IRestorable<T> {
  constructor(options: WidgetTracker.IOptions);
  add(widget: T): Promise<void>;
  readonly currentChanged: ISignal<this, T | null>;
  readonly currentWidget: T | null;
  dispose(): void;
  filter(fn: (widget: T) => boolean): T[];
  find(fn: (widget: T) => boolean): T | undefined;
  forEach(fn: (widget: T) => void): void;
  has(widget: Widget): boolean;
  inject(widget: T): Promise<void>;
  readonly isDisposed: boolean;
  readonly namespace: string;
  protected onCurrentChanged(value: T | null): void;
  restore(options: IRestorable.IOptions<T>): Promise<any>;
  readonly restored: Promise<void>;
  save(widget: T): Promise<void>;
  readonly size: number;
  readonly widgetAdded: ISignal<this, T>;
  readonly widgetUpdated: ISignal<this, T>;
}

// @public
export namespace WidgetTracker {
  export interface IOptions {
    namespace: string;
  }
}

// @public
export class WindowResolver implements IWindowResolver {
  readonly name: string;
  resolve(candidate: string): Promise<void>;
}

// (No @packageDocumentation comment for this package)
```
