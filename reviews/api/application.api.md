## API Report File for "@jupyterlab/application"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { Application } from '@phosphor/application';
import { CommandLinker } from '@jupyterlab/apputils';
import { CommandRegistry } from '@phosphor/commands';
import { DockLayout } from '@phosphor/widgets';
import { DockPanel } from '@phosphor/widgets';
import { DocumentRegistry } from '@jupyterlab/docregistry';
import { FocusTracker } from '@phosphor/widgets';
import { IDataConnector } from '@jupyterlab/coreutils';
import { IDisposable } from '@phosphor/disposable';
import { IIterator } from '@phosphor/algorithm';
import { IPlugin } from '@phosphor/application';
import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
import { IRestorer } from '@jupyterlab/coreutils';
import { ISignal } from '@phosphor/signaling';
import { IWidgetTracker } from '@jupyterlab/apputils';
import { Message } from '@phosphor/messaging';
import { MimeDocument } from '@jupyterlab/docregistry';
import { ReadonlyJSONObject } from '@phosphor/coreutils';
import { ReadonlyJSONValue } from '@phosphor/coreutils';
import { ServerConnection } from '@jupyterlab/services';
import { ServiceManager } from '@jupyterlab/services';
import { Token } from '@phosphor/coreutils';
import { Widget } from '@phosphor/widgets';
import { WidgetTracker } from '@jupyterlab/apputils';

// @public
export const ConnectionLost: IConnectionLost;

// @public
export const IConnectionLost: Token<IConnectionLost>;

// @public
export type IConnectionLost = (
  manager: ServiceManager.IManager,
  err: ServerConnection.NetworkError
) => Promise<void>;

// @public
export const ILabShell: Token<ILabShell>;

// @public
export interface ILabShell extends LabShell {}

// @public
export namespace ILabShell {
  export type Area = 'main' | 'header' | 'top' | 'left' | 'right' | 'bottom';
  export type AreaConfig = DockLayout.AreaConfig;
  export type IChangedArgs = FocusTracker.IChangedArgs<Widget>;
  export interface ILayout {
    readonly fresh?: boolean;
    readonly leftArea: ISideArea | null;
    readonly mainArea: IMainArea | null;
    readonly rightArea: ISideArea | null;
  }
  export interface IMainArea {
    readonly currentWidget: Widget | null;
    readonly dock: DockLayout.ILayoutConfig | null;
    readonly mode: DockPanel.Mode | null;
  }
  export interface ISideArea {
    readonly collapsed: boolean;
    readonly currentWidget: Widget | null;
    readonly widgets: Array<Widget> | null;
  }
}

// @public
export const ILabStatus: Token<ILabStatus>;

// @public
export interface ILabStatus {
  readonly busySignal: ISignal<JupyterFrontEnd, boolean>;
  readonly dirtySignal: ISignal<JupyterFrontEnd, boolean>;
  readonly isBusy: boolean;
  readonly isDirty: boolean;
  setBusy(): IDisposable;
  setDirty(): IDisposable;
}

// @public
export const ILayoutRestorer: Token<ILayoutRestorer>;

// @public
export interface ILayoutRestorer extends IRestorer {
  add(widget: Widget, name: string): void;
  restore<T extends Widget>(
    tracker: WidgetTracker<T>,
    options: IRestorer.IOptions<T>
  ): Promise<any>;
  restored: Promise<void>;
}

// @public
export interface IMimeDocumentTracker extends IWidgetTracker<MimeDocument> {}

// @public
export const IMimeDocumentTracker: Token<IMimeDocumentTracker>;

// @public
export const IRouter: Token<IRouter>;

// @public
export interface IRouter {
  readonly base: string;
  readonly commands: CommandRegistry;
  readonly current: IRouter.ILocation;
  navigate(path: string, options?: IRouter.INavOptions): void;
  register(options: IRouter.IRegisterOptions): IDisposable;
  reload(): void;
  route(url: string): void;
  readonly routed: ISignal<IRouter, IRouter.ILocation>;
  readonly stop: Token<void>;
}

// @public
export namespace IRouter {
  export interface ILocation extends ReadonlyJSONObject {
    hash: string;
    path: string;
    request: string;
    search: string;
  }
  export interface INavOptions {
    hard?: boolean;
  }
  export interface IRegisterOptions {
    command: string;
    pattern: RegExp;
    rank?: number;
  }
}

// @public
export abstract class JupyterFrontEnd<
  T extends JupyterFrontEnd.IShell = JupyterFrontEnd.IShell
> extends Application<T> {
  constructor(options: JupyterFrontEnd.IOptions<T>);
  readonly commandLinker: CommandLinker;
  contextMenuHitTest(
    test: (node: HTMLElement) => boolean
  ): HTMLElement | undefined;
  readonly docRegistry: DocumentRegistry;
  protected evtContextMenu(event: MouseEvent): void;
  abstract readonly name: string;
  abstract readonly namespace: string;
  readonly restored: Promise<void>;
  readonly serviceManager: ServiceManager;
  abstract readonly version: string;
}

// @public
export namespace JupyterFrontEnd {
  export interface IOptions<T extends IShell = IShell, U = any>
    extends Application.IOptions<T> {
    commandLinker?: CommandLinker;
    docRegistry?: DocumentRegistry;
    restored?: Promise<U>;
    serviceManager?: ServiceManager;
  }
  export interface IPaths {
    readonly directories: {
      readonly appSettings: string;
      readonly schemas: string;
      readonly static: string;
      readonly templates: string;
      readonly themes: string;
      readonly userSettings: string;
      readonly serverRoot: string;
      readonly workspaces: string;
    };
    readonly urls: {
      readonly base: string;
      readonly notFound?: string;
      readonly app: string;
      readonly static: string;
      readonly settings: string;
      readonly themes: string;
      readonly tree: string;
      readonly workspaces: string;
      readonly hubPrefix?: string;
      readonly hubHost?: string;
      readonly hubUser?: string;
      readonly hubServerName?: string;
    };
  }
  const IPaths: Token<IPaths>;
  export interface IShell extends Widget {
    activateById(id: string): void;
    add(
      widget: Widget,
      area?: string,
      options?: DocumentRegistry.IOpenOptions
    ): void;
    readonly currentWidget: Widget;
    widgets(area?: string): IIterator<Widget>;
  }
}

// @public
export type JupyterFrontEndPlugin<T> = IPlugin<JupyterFrontEnd, T>;

// @public
export class JupyterLab extends JupyterFrontEnd<ILabShell> {
  constructor(options?: JupyterLab.IOptions);
  readonly info: JupyterLab.IInfo;
  readonly name: string;
  readonly namespace: string;
  readonly paths: JupyterFrontEnd.IPaths;
  readonly registerPluginErrors: Array<Error>;
  registerPluginModule(mod: JupyterLab.IPluginModule): void;
  registerPluginModules(mods: JupyterLab.IPluginModule[]): void;
  readonly restored: Promise<void>;
  // Warning: (ae-forgotten-export) The symbol "LabStatus" needs to be exported by the entry point index.d.ts
  readonly status: LabStatus;
  readonly version: string;
}

// @public
export namespace JupyterLab {
  export interface IInfo {
    readonly deferred: {
      patterns: string[];
      matches: string[];
    };
    readonly devMode: boolean;
    readonly disabled: {
      patterns: string[];
      matches: string[];
    };
    readonly filesCached: boolean;
    readonly mimeExtensions: IRenderMime.IExtensionModule[];
  }
  const IInfo: Token<IInfo>;
  export interface IOptions
    extends JupyterFrontEnd.IOptions<LabShell>,
      Partial<IInfo> {
    // (undocumented)
    paths?: Partial<JupyterFrontEnd.IPaths>;
  }
  const defaultInfo: IInfo;
  const defaultPaths: JupyterFrontEnd.IPaths;
  export interface IPluginModule {
    default: JupyterFrontEndPlugin<any> | JupyterFrontEndPlugin<any>[];
  }
}

// @public
export class LabShell extends Widget implements JupyterFrontEnd.IShell {
  constructor();
  activateById(id: string): void;
  // (undocumented)
  activateNextTab(): void;
  // (undocumented)
  activatePreviousTab(): void;
  readonly activeChanged: ISignal<this, ILabShell.IChangedArgs>;
  readonly activeWidget: Widget | null;
  // (undocumented)
  add(
    widget: Widget,
    area?: ILabShell.Area,
    options?: DocumentRegistry.IOpenOptions
  ): void;
  closeAll(): void;
  collapseLeft(): void;
  collapseRight(): void;
  readonly currentChanged: ISignal<this, ILabShell.IChangedArgs>;
  readonly currentWidget: Widget | null;
  dispose(): void;
  expandLeft(): void;
  expandRight(): void;
  isEmpty(area: ILabShell.Area): boolean;
  readonly layoutModified: ISignal<this, void>;
  readonly leftCollapsed: boolean;
  mode: DockPanel.Mode;
  protected onAfterAttach(msg: Message): void;
  presentationMode: boolean;
  readonly restored: Promise<ILabShell.ILayout>;
  restoreLayout(layout: ILabShell.ILayout): void;
  readonly rightCollapsed: boolean;
  saveLayout(): ILabShell.ILayout;
  widgets(area?: ILabShell.Area): IIterator<Widget>;
}

// @public
export class LayoutRestorer implements ILayoutRestorer {
  constructor(options: LayoutRestorer.IOptions);
  add(widget: Widget, name: string): void;
  fetch(): Promise<ILabShell.ILayout>;
  restore(
    tracker: WidgetTracker,
    options: IRestorer.IOptions<Widget>
  ): Promise<any>;
  readonly restored: Promise<void>;
  save(data: ILabShell.ILayout): Promise<void>;
}

// @public
export namespace LayoutRestorer {
  export interface IOptions {
    connector: IDataConnector<ReadonlyJSONValue>;
    first: Promise<any>;
    registry: CommandRegistry;
  }
}

// @public
export class Router implements IRouter {
  constructor(options: Router.IOptions);
  readonly base: string;
  readonly commands: CommandRegistry;
  readonly current: IRouter.ILocation;
  navigate(path: string, options?: IRouter.INavOptions): void;
  register(options: IRouter.IRegisterOptions): IDisposable;
  reload(): void;
  route(): Promise<void>;
  readonly routed: ISignal<this, IRouter.ILocation>;
  readonly stop: Token<void>;
}

// @public
export namespace Router {
  export interface IOptions {
    base: string;
    commands: CommandRegistry;
  }
}

// (No @packageDocumentation comment for this package)
```
