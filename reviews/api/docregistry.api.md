## API Report File for "@jupyterlab/docregistry"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { ClientSession } from '@jupyterlab/apputils';
import { CodeEditor } from '@jupyterlab/codeeditor';
import { Contents } from '@jupyterlab/services';
import { DockLayout } from '@phosphor/widgets';
import { IChangedArgs } from '@jupyterlab/coreutils';
import { IClientSession } from '@jupyterlab/apputils';
import { IDisposable } from '@phosphor/disposable';
import { IIterator } from '@phosphor/algorithm';
import { IModelDB } from '@jupyterlab/observables';
import { IRenderMime } from '@jupyterlab/rendermime-interfaces';
import { IRenderMime as IRenderMime_2 } from '@jupyterlab/rendermime';
import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
import { ISignal } from '@phosphor/signaling';
import { JSONValue } from '@phosphor/coreutils';
import { Kernel } from '@jupyterlab/services';
import { MainAreaWidget } from '@jupyterlab/apputils';
import { Message } from '@phosphor/messaging';
import { ModelDB } from '@jupyterlab/observables';
import { Printing } from '@jupyterlab/apputils';
import { ServiceManager } from '@jupyterlab/services';
import { Toolbar } from '@jupyterlab/apputils';
import { Widget } from '@phosphor/widgets';

// @public
export abstract class ABCWidgetFactory<
  T extends IDocumentWidget,
  U extends DocumentRegistry.IModel = DocumentRegistry.IModel
> implements DocumentRegistry.IWidgetFactory<T, U> {
  constructor(options: DocumentRegistry.IWidgetFactoryOptions<T>);
  readonly canStartKernel: boolean;
  createNew(context: DocumentRegistry.IContext<U>, source?: T): T;
  protected abstract createNewWidget(
    context: DocumentRegistry.IContext<U>,
    source?: T
  ): T;
  readonly defaultFor: string[];
  readonly defaultRendered: string[];
  protected defaultToolbarFactory(widget: T): DocumentRegistry.IToolbarItem[];
  dispose(): void;
  readonly fileTypes: string[];
  readonly isDisposed: boolean;
  readonly modelName: string;
  readonly name: string;
  readonly preferKernel: boolean;
  readonly readOnly: boolean;
  shutdownOnClose: boolean;
  readonly widgetCreated: ISignal<DocumentRegistry.IWidgetFactory<T, U>, T>;
}

// @public
export class Base64ModelFactory extends TextModelFactory {
  readonly contentType: Contents.ContentType;
  readonly fileFormat: Contents.FileFormat;
  readonly name: string;
}

// @public
export class Context<T extends DocumentRegistry.IModel>
  implements DocumentRegistry.IContext<T> {
  constructor(options: Context.IOptions<T>);
  addSibling(
    widget: Widget,
    options?: DocumentRegistry.IOpenOptions
  ): IDisposable;
  readonly contentsModel: Contents.IModel | null;
  createCheckpoint(): Promise<Contents.ICheckpointModel>;
  deleteCheckpoint(checkpointId: string): Promise<void>;
  dispose(): void;
  readonly disposed: ISignal<this, void>;
  download(): Promise<void>;
  readonly factoryName: string;
  readonly fileChanged: ISignal<this, Contents.IModel>;
  initialize(isNew: boolean): Promise<void>;
  readonly isDisposed: boolean;
  readonly isReady: boolean;
  listCheckpoints(): Promise<Contents.ICheckpointModel[]>;
  readonly localPath: string;
  readonly model: T;
  readonly path: string;
  readonly pathChanged: ISignal<this, string>;
  readonly ready: Promise<void>;
  restoreCheckpoint(checkpointId?: string): Promise<void>;
  revert(): Promise<void>;
  save(): Promise<void>;
  saveAs(): Promise<void>;
  readonly saveState: ISignal<this, DocumentRegistry.SaveState>;
  readonly session: ClientSession;
  readonly urlResolver: IRenderMime.IResolver;
}

// @public
export namespace Context {
  export interface IOptions<T extends DocumentRegistry.IModel> {
    factory: DocumentRegistry.IModelFactory<T>;
    kernelPreference?: IClientSession.IKernelPreference;
    manager: ServiceManager.IManager;
    modelDBFactory?: ModelDB.IFactory;
    opener?: (widget: Widget) => void;
    path: string;
    setBusy?: () => IDisposable;
  }
}

// @public
export class DocumentModel extends CodeEditor.Model
  implements DocumentRegistry.ICodeModel {
  constructor(languagePreference?: string, modelDB?: IModelDB);
  readonly contentChanged: ISignal<this, void>;
  readonly defaultKernelLanguage: string;
  readonly defaultKernelName: string;
  dirty: boolean;
  fromJSON(value: JSONValue): void;
  fromString(value: string): void;
  initialize(): void;
  readOnly: boolean;
  readonly stateChanged: ISignal<this, IChangedArgs<any>>;
  toJSON(): JSONValue;
  toString(): string;
  protected triggerContentChange(): void;
  protected triggerStateChange(args: IChangedArgs<any>): void;
}

// @public
export class DocumentRegistry implements IDisposable {
  constructor(options?: DocumentRegistry.IOptions);
  addFileType(fileType: Partial<DocumentRegistry.IFileType>): IDisposable;
  addModelFactory(factory: DocumentRegistry.ModelFactory): IDisposable;
  addWidgetExtension(
    widgetName: string,
    extension: DocumentRegistry.WidgetExtension
  ): IDisposable;
  addWidgetFactory(factory: DocumentRegistry.WidgetFactory): IDisposable;
  readonly changed: ISignal<this, DocumentRegistry.IChangedArgs>;
  defaultRenderedWidgetFactory(path: string): DocumentRegistry.WidgetFactory;
  defaultWidgetFactory(path?: string): DocumentRegistry.WidgetFactory;
  dispose(): void;
  fileTypes(): IIterator<DocumentRegistry.IFileType>;
  getFileType(name: string): DocumentRegistry.IFileType | undefined;
  getFileTypeForModel(
    model: Partial<Contents.IModel>
  ): DocumentRegistry.IFileType;
  getFileTypesForPath(path: string): DocumentRegistry.IFileType[];
  getKernelPreference(
    path: string,
    widgetName: string,
    kernel?: Partial<Kernel.IModel>
  ): IClientSession.IKernelPreference | undefined;
  getModelFactory(name: string): DocumentRegistry.ModelFactory | undefined;
  getWidgetFactory(
    widgetName: string
  ): DocumentRegistry.WidgetFactory | undefined;
  readonly isDisposed: boolean;
  modelFactories(): IIterator<DocumentRegistry.ModelFactory>;
  preferredWidgetFactories(path: string): DocumentRegistry.WidgetFactory[];
  setDefaultWidgetFactory(fileType: string, factory: string | undefined): void;
  widgetExtensions(
    widgetName: string
  ): IIterator<DocumentRegistry.WidgetExtension>;
  widgetFactories(): IIterator<DocumentRegistry.WidgetFactory>;
}

// @public
export namespace DocumentRegistry {
  export type CodeContext = IContext<ICodeModel>;
  export type CodeModelFactory = IModelFactory<ICodeModel>;
  export type Context = IContext<IModel>;
  export interface IChangedArgs {
    readonly change: 'added' | 'removed';
    readonly name: string;
    readonly type:
      | 'widgetFactory'
      | 'modelFactory'
      | 'widgetExtension'
      | 'fileType';
  }
  export interface ICodeModel extends IModel, CodeEditor.IModel {}
  export interface IContext<T extends IModel> extends IDisposable {
    addSibling(widget: Widget, options?: IOpenOptions): IDisposable;
    readonly contentsModel: Contents.IModel | null;
    createCheckpoint(): Promise<Contents.ICheckpointModel>;
    deleteCheckpoint(checkpointID: string): Promise<void>;
    disposed: ISignal<this, void>;
    download(): Promise<void>;
    fileChanged: ISignal<this, Contents.IModel>;
    readonly isReady: boolean;
    listCheckpoints(): Promise<Contents.ICheckpointModel[]>;
    readonly localPath: string;
    readonly model: T;
    readonly path: string;
    pathChanged: ISignal<this, string>;
    readonly ready: Promise<void>;
    restoreCheckpoint(checkpointID?: string): Promise<void>;
    revert(): Promise<void>;
    save(): Promise<void>;
    saveAs(): Promise<void>;
    saveState: ISignal<this, SaveState>;
    readonly session: IClientSession;
    readonly urlResolver: IRenderMime.IResolver;
  }
  export interface IFileType {
    readonly contentType: Contents.ContentType;
    readonly displayName?: string;
    readonly extensions: ReadonlyArray<string>;
    readonly fileFormat: Contents.FileFormat;
    readonly iconClass?: string;
    readonly iconLabel?: string;
    readonly mimeTypes: ReadonlyArray<string>;
    readonly name: string;
    readonly pattern?: string;
  }
  export interface IModel extends IDisposable {
    contentChanged: ISignal<this, void>;
    readonly defaultKernelLanguage: string;
    readonly defaultKernelName: string;
    dirty: boolean;
    fromJSON(value: any): void;
    fromString(value: string): void;
    initialize(): void;
    readonly modelDB: IModelDB;
    readOnly: boolean;
    stateChanged: ISignal<this, IChangedArgs<any>>;
    toJSON(): JSONValue;
    toString(): string;
  }
  export interface IModelFactory<T extends IModel> extends IDisposable {
    readonly contentType: Contents.ContentType;
    createNew(languagePreference?: string, modelDB?: IModelDB): T;
    readonly fileFormat: Contents.FileFormat;
    readonly name: string;
    preferredLanguage(path: string): string;
  }
  export interface IOpenOptions {
    activate?: boolean;
    mode?: DockLayout.InsertMode;
    rank?: number;
    ref?: string | null;
  }
  export interface IOptions {
    initialFileTypes?: DocumentRegistry.IFileType[];
    textModelFactory?: ModelFactory;
  }
  export interface IToolbarItem {
    // (undocumented)
    name: string;
    // (undocumented)
    widget: Widget;
  }
  export interface IWidgetExtension<T extends Widget, U extends IModel> {
    createNew(widget: T, context: IContext<U>): IDisposable;
  }
  export interface IWidgetFactory<T extends IDocumentWidget, U extends IModel>
    extends IDisposable,
      IWidgetFactoryOptions {
    createNew(context: IContext<U>, source?: T): T;
    widgetCreated: ISignal<IWidgetFactory<T, U>, T>;
  }
  export interface IWidgetFactoryOptions<T extends Widget = Widget> {
    readonly canStartKernel?: boolean;
    readonly defaultFor?: ReadonlyArray<string>;
    readonly defaultRendered?: ReadonlyArray<string>;
    readonly fileTypes: ReadonlyArray<string>;
    readonly modelName?: string;
    readonly name: string;
    readonly preferKernel?: boolean;
    readonly readOnly?: boolean;
    readonly shutdownOnClose?: boolean;
    readonly toolbarFactory?: (widget: T) => DocumentRegistry.IToolbarItem[];
  }
  export type ModelFactory = IModelFactory<IModel>;
  // (undocumented)
  export type SaveState = 'started' | 'completed' | 'failed';
  export type WidgetExtension = IWidgetExtension<Widget, IModel>;
  const fileTypeDefaults: IFileType;
  export type WidgetFactory = IWidgetFactory<IDocumentWidget, IModel>;
  const defaultTextFileType: IFileType;
  const defaultNotebookFileType: IFileType;
  const defaultDirectoryFileType: IFileType;
  const defaultFileTypes: ReadonlyArray<Partial<IFileType>>;
}

// @public
export class DocumentWidget<
  T extends Widget = Widget,
  U extends DocumentRegistry.IModel = DocumentRegistry.IModel
> extends MainAreaWidget<T> implements IDocumentWidget<T, U> {
  constructor(options: DocumentWidget.IOptions<T, U>);
  // (undocumented)
  readonly context: DocumentRegistry.IContext<U>;
  setFragment(fragment: string): void;
}

// @public (undocumented)
export namespace DocumentWidget {
  // (undocumented)
  export interface IOptions<
    T extends Widget = Widget,
    U extends DocumentRegistry.IModel = DocumentRegistry.IModel
  > extends MainAreaWidget.IOptions<T> {
    // (undocumented)
    context: DocumentRegistry.IContext<U>;
  }
  // (undocumented)
  export interface IOptionsOptionalContent<
    T extends Widget = Widget,
    U extends DocumentRegistry.IModel = DocumentRegistry.IModel
  > extends MainAreaWidget.IOptionsOptionalContent<T> {
    // (undocumented)
    context: DocumentRegistry.IContext<U>;
  }
}

// @public
export interface IDocumentWidget<
  T extends Widget = Widget,
  U extends DocumentRegistry.IModel = DocumentRegistry.IModel
> extends Widget {
  readonly content: T;
  readonly context: DocumentRegistry.IContext<U>;
  readonly revealed: Promise<void>;
  setFragment(fragment: string): void;
  readonly toolbar: Toolbar<Widget>;
}

// @public
export class MimeContent extends Widget {
  [Printing.symbol](): Printing.OptionalAsyncThunk;
  constructor(options: MimeContent.IOptions);
  dispose(): void;
  readonly mimeType: string;
  protected onUpdateRequest(msg: Message): void;
  readonly ready: Promise<void>;
  // (undocumented)
  readonly renderer: IRenderMime_2.IRenderer;
  setFragment(fragment: string): void;
}

// @public
export namespace MimeContent {
  export interface IOptions {
    context: DocumentRegistry.IContext<DocumentRegistry.IModel>;
    dataType?: 'string' | 'json';
    mimeType: string;
    renderer: IRenderMime_2.IRenderer;
    renderTimeout: number;
  }
}

// @public
export class MimeDocument extends DocumentWidget<MimeContent> {
  // (undocumented)
  setFragment(fragment: string): void;
}

// @public
export class MimeDocumentFactory extends ABCWidgetFactory<MimeDocument> {
  constructor(options: MimeDocumentFactory.IOptions<MimeDocument>);
  protected createNewWidget(context: DocumentRegistry.Context): MimeDocument;
}

// @public
export namespace MimeDocumentFactory {
  export interface IOptions<T extends MimeDocument>
    extends DocumentRegistry.IWidgetFactoryOptions<T> {
    dataType?: 'string' | 'json';
    primaryFileType: DocumentRegistry.IFileType;
    rendermime: IRenderMimeRegistry;
    renderTimeout?: number;
  }
}

// @public
export class TextModelFactory implements DocumentRegistry.CodeModelFactory {
  readonly contentType: Contents.ContentType;
  createNew(
    languagePreference?: string,
    modelDB?: IModelDB
  ): DocumentRegistry.ICodeModel;
  dispose(): void;
  readonly fileFormat: Contents.FileFormat;
  readonly isDisposed: boolean;
  readonly name: string;
  preferredLanguage(path: string): string;
}

// (No @packageDocumentation comment for this package)
```
