## API Report File for "@jupyterlab/services"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { DataConnector } from '@jupyterlab/coreutils';
import { IDisposable } from '@phosphor/disposable';
import { IIterator } from '@phosphor/algorithm';
import { ISettingRegistry } from '@jupyterlab/coreutils';
import { ISignal } from '@phosphor/signaling';
import { JSONObject } from '@phosphor/coreutils';
import { JSONPrimitive } from '@phosphor/coreutils';
import { JSONValue } from '@phosphor/coreutils';
import { ModelDB } from '@jupyterlab/observables';
import { nbformat } from '@jupyterlab/coreutils';
import { Poll } from '@jupyterlab/coreutils';
import { ReadonlyJSONObject } from '@phosphor/coreutils';

// @public
export namespace Builder {
  // Warning: (ae-forgotten-export) The symbol "BuildManager" needs to be exported by the entry point index.d.ts
  export interface IManager extends BuildManager {}
}

// @public
export namespace ConfigSection {
  export function create(
    options: ConfigSection.IOptions
  ): Promise<IConfigSection>;
  export interface IOptions {
    name: string;
    serverSettings?: ServerConnection.ISettings;
  }
}

// @public
export class ConfigWithDefaults {
  constructor(options: ConfigWithDefaults.IOptions);
  get(key: string): JSONValue;
  set(key: string, value: JSONValue): Promise<JSONValue>;
}

// @public
export namespace ConfigWithDefaults {
  export interface IOptions {
    className?: string;
    defaults?: JSONObject;
    section: IConfigSection;
  }
}

// @public
export namespace Contents {
  export type ContentType = 'notebook' | 'file' | 'directory';
  export type FileFormat = 'json' | 'text' | 'base64';
  export interface IChangedArgs {
    newValue: Partial<IModel> | null;
    oldValue: Partial<IModel> | null;
    type: 'new' | 'delete' | 'rename' | 'save';
  }
  export interface ICheckpointModel {
    readonly id: string;
    readonly last_modified: string;
  }
  export interface ICreateOptions {
    ext?: string;
    path?: string;
    type?: ContentType;
  }
  export interface IDrive extends IDisposable {
    copy(localPath: string, toLocalDir: string): Promise<IModel>;
    createCheckpoint(localPath: string): Promise<ICheckpointModel>;
    delete(localPath: string): Promise<void>;
    deleteCheckpoint(localPath: string, checkpointID: string): Promise<void>;
    fileChanged: ISignal<IDrive, IChangedArgs>;
    get(localPath: string, options?: IFetchOptions): Promise<IModel>;
    getDownloadUrl(localPath: string): Promise<string>;
    listCheckpoints(localPath: string): Promise<ICheckpointModel[]>;
    readonly modelDBFactory?: ModelDB.IFactory;
    readonly name: string;
    newUntitled(options?: ICreateOptions): Promise<IModel>;
    rename(oldLocalPath: string, newLocalPath: string): Promise<IModel>;
    restoreCheckpoint(localPath: string, checkpointID: string): Promise<void>;
    save(localPath: string, options?: Partial<IModel>): Promise<IModel>;
    readonly serverSettings: ServerConnection.ISettings;
  }
  export interface IFetchOptions {
    content?: boolean;
    format?: FileFormat;
    type?: ContentType;
  }
  export interface IManager extends IDisposable {
    addDrive(drive: IDrive): void;
    copy(path: string, toDir: string): Promise<IModel>;
    createCheckpoint(path: string): Promise<ICheckpointModel>;
    delete(path: string): Promise<void>;
    deleteCheckpoint(path: string, checkpointID: string): Promise<void>;
    driveName(path: string): string;
    readonly fileChanged: ISignal<IManager, IChangedArgs>;
    get(path: string, options?: IFetchOptions): Promise<IModel>;
    getDownloadUrl(path: string): Promise<string>;
    getModelDBFactory(path: string): ModelDB.IFactory | null;
    listCheckpoints(path: string): Promise<ICheckpointModel[]>;
    localPath(path: string): string;
    newUntitled(options?: ICreateOptions): Promise<IModel>;
    normalize(path: string): string;
    rename(path: string, newPath: string): Promise<IModel>;
    restoreCheckpoint(path: string, checkpointID: string): Promise<void>;
    save(path: string, options?: Partial<IModel>): Promise<IModel>;
    readonly serverSettings: ServerConnection.ISettings;
  }
  export interface IModel {
    readonly chunk?: number;
    readonly content: any;
    readonly created: string;
    readonly format: FileFormat;
    readonly last_modified: string;
    readonly mimetype: string;
    readonly name: string;
    readonly path: string;
    readonly type: ContentType;
    readonly writable: boolean;
  }
  export function validateCheckpointModel(checkpoint: ICheckpointModel): void;
  export function validateContentsModel(contents: IModel): void;
}

// @public
export class ContentsManager implements Contents.IManager {
  constructor(options?: ContentsManager.IOptions);
  addDrive(drive: Contents.IDrive): void;
  copy(fromFile: string, toDir: string): Promise<Contents.IModel>;
  createCheckpoint(path: string): Promise<Contents.ICheckpointModel>;
  delete(path: string): Promise<void>;
  deleteCheckpoint(path: string, checkpointID: string): Promise<void>;
  dispose(): void;
  driveName(path: string): string;
  readonly fileChanged: ISignal<this, Contents.IChangedArgs>;
  get(path: string, options?: Contents.IFetchOptions): Promise<Contents.IModel>;
  getDownloadUrl(path: string): Promise<string>;
  getModelDBFactory(path: string): ModelDB.IFactory | null;
  readonly isDisposed: boolean;
  listCheckpoints(path: string): Promise<Contents.ICheckpointModel[]>;
  localPath(path: string): string;
  newUntitled(options?: Contents.ICreateOptions): Promise<Contents.IModel>;
  normalize(path: string): string;
  rename(path: string, newPath: string): Promise<Contents.IModel>;
  restoreCheckpoint(path: string, checkpointID: string): Promise<void>;
  save(
    path: string,
    options?: Partial<Contents.IModel>
  ): Promise<Contents.IModel>;
  readonly serverSettings: ServerConnection.ISettings;
}

// @public
export namespace ContentsManager {
  export interface IOptions {
    defaultDrive?: Contents.IDrive;
    serverSettings?: ServerConnection.ISettings;
  }
}

// @public
export class Drive implements Contents.IDrive {
  constructor(options?: Drive.IOptions);
  copy(fromFile: string, toDir: string): Promise<Contents.IModel>;
  createCheckpoint(localPath: string): Promise<Contents.ICheckpointModel>;
  delete(localPath: string): Promise<void>;
  deleteCheckpoint(localPath: string, checkpointID: string): Promise<void>;
  dispose(): void;
  readonly fileChanged: ISignal<this, Contents.IChangedArgs>;
  get(
    localPath: string,
    options?: Contents.IFetchOptions
  ): Promise<Contents.IModel>;
  getDownloadUrl(localPath: string): Promise<string>;
  readonly isDisposed: boolean;
  listCheckpoints(localPath: string): Promise<Contents.ICheckpointModel[]>;
  readonly name: string;
  newUntitled(options?: Contents.ICreateOptions): Promise<Contents.IModel>;
  rename(oldLocalPath: string, newLocalPath: string): Promise<Contents.IModel>;
  restoreCheckpoint(localPath: string, checkpointID: string): Promise<void>;
  save(
    localPath: string,
    options?: Partial<Contents.IModel>
  ): Promise<Contents.IModel>;
  readonly serverSettings: ServerConnection.ISettings;
}

// @public
export namespace Drive {
  export interface IOptions {
    apiEndpoint?: string;
    name?: string;
    serverSettings?: ServerConnection.ISettings;
  }
}

// @public
export interface IConfigSection {
  readonly data: JSONObject;
  readonly serverSettings: ServerConnection.ISettings;
  update(newdata: JSONObject): Promise<JSONObject>;
}

// @public
export namespace Kernel {
  export function connectTo(
    model: Kernel.IModel,
    settings?: ServerConnection.ISettings
  ): IKernel;
  export function findById(
    id: string,
    settings?: ServerConnection.ISettings
  ): Promise<IModel>;
  export function getSpecs(
    settings?: ServerConnection.ISettings
  ): Promise<Kernel.ISpecModels>;
  export interface IAnyMessageArgs {
    direction: 'send' | 'recv';
    msg: Readonly<KernelMessage.IMessage>;
  }
  export interface IComm extends IDisposable {
    close(
      data?: JSONValue,
      metadata?: JSONObject,
      buffers?: (ArrayBuffer | ArrayBufferView)[]
    ): IShellFuture;
    readonly commId: string;
    onClose: (msg: KernelMessage.ICommCloseMsg) => void | PromiseLike<void>;
    onMsg: (msg: KernelMessage.ICommMsgMsg) => void | PromiseLike<void>;
    open(
      data?: JSONValue,
      metadata?: JSONObject,
      buffers?: (ArrayBuffer | ArrayBufferView)[]
    ): IShellFuture;
    send(
      data: JSONValue,
      metadata?: JSONObject,
      buffers?: (ArrayBuffer | ArrayBufferView)[],
      disposeOnDone?: boolean
    ): IShellFuture;
    readonly targetName: string;
  }
  // (undocumented)
  export interface IControlFuture<
    REQUEST extends KernelMessage.IControlMessage = KernelMessage.IControlMessage,
    REPLY extends KernelMessage.IControlMessage = KernelMessage.IControlMessage
  > extends IFuture<REQUEST, REPLY> {}
  export interface IFuture<
    REQUEST extends KernelMessage.IShellControlMessage,
    REPLY extends KernelMessage.IShellControlMessage
  > extends IDisposable {
    readonly done: Promise<REPLY | undefined>;
    readonly msg: REQUEST;
    onIOPub: (msg: KernelMessage.IIOPubMessage) => void | PromiseLike<void>;
    onReply: (msg: REPLY) => void | PromiseLike<void>;
    onStdin: (msg: KernelMessage.IStdinMessage) => void | PromiseLike<void>;
    registerMessageHook(
      hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>
    ): void;
    removeMessageHook(
      hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>
    ): void;
    sendInputReply(content: KernelMessage.IInputReplyMsg['content']): void;
  }
  export interface IKernel extends IKernelConnection {
    anyMessage: ISignal<this, IAnyMessageArgs>;
    iopubMessage: ISignal<this, KernelMessage.IIOPubMessage>;
    readonly serverSettings: ServerConnection.ISettings;
    shutdown(): Promise<void>;
    statusChanged: ISignal<this, Kernel.Status>;
    terminated: ISignal<this, void>;
    unhandledMessage: ISignal<this, KernelMessage.IMessage>;
  }
  export interface IKernelConnection extends IDisposable {
    readonly clientId: string;
    connectToComm(targetName: string, commId?: string): Kernel.IComm;
    getSpec(): Promise<Kernel.ISpecModel>;
    handleComms: boolean;
    readonly id: string;
    readonly info: KernelMessage.IInfoReply | null;
    interrupt(): Promise<void>;
    readonly isReady: boolean;
    readonly model: Kernel.IModel;
    readonly name: string;
    readonly ready: Promise<void>;
    reconnect(): Promise<void>;
    registerCommTarget(
      targetName: string,
      callback: (
        comm: Kernel.IComm,
        msg: KernelMessage.ICommOpenMsg
      ) => void | PromiseLike<void>
    ): void;
    registerMessageHook(
      msgId: string,
      hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>
    ): void;
    removeCommTarget(
      targetName: string,
      callback: (
        comm: Kernel.IComm,
        msg: KernelMessage.ICommOpenMsg
      ) => void | PromiseLike<void>
    ): void;
    removeMessageHook(
      msgId: string,
      hook: (msg: KernelMessage.IIOPubMessage) => boolean | PromiseLike<boolean>
    ): void;
    requestCommInfo(
      content: KernelMessage.ICommInfoRequestMsg['content']
    ): Promise<KernelMessage.ICommInfoReplyMsg>;
    requestComplete(
      content: KernelMessage.ICompleteRequestMsg['content']
    ): Promise<KernelMessage.ICompleteReplyMsg>;
    requestDebug(
      content: KernelMessage.IDebugRequestMsg['content'],
      disposeOnDone?: boolean
    ): Kernel.IControlFuture<
      KernelMessage.IDebugRequestMsg,
      KernelMessage.IDebugReplyMsg
    >;
    requestExecute(
      content: KernelMessage.IExecuteRequestMsg['content'],
      disposeOnDone?: boolean,
      metadata?: JSONObject
    ): Kernel.IShellFuture<
      KernelMessage.IExecuteRequestMsg,
      KernelMessage.IExecuteReplyMsg
    >;
    requestHistory(
      content: KernelMessage.IHistoryRequestMsg['content']
    ): Promise<KernelMessage.IHistoryReplyMsg>;
    requestInspect(
      content: KernelMessage.IInspectRequestMsg['content']
    ): Promise<KernelMessage.IInspectReplyMsg>;
    requestIsComplete(
      content: KernelMessage.IIsCompleteRequestMsg['content']
    ): Promise<KernelMessage.IIsCompleteReplyMsg>;
    requestKernelInfo(): Promise<KernelMessage.IInfoReplyMsg>;
    restart(): Promise<void>;
    // (undocumented)
    sendControlMessage<T extends KernelMessage.ControlMessageType>(
      msg: KernelMessage.IControlMessage<T>,
      expectReply?: boolean,
      disposeOnDone?: boolean
    ): Kernel.IControlFuture<KernelMessage.IControlMessage<T>>;
    sendInputReply(content: KernelMessage.IInputReplyMsg['content']): void;
    sendShellMessage<T extends KernelMessage.ShellMessageType>(
      msg: KernelMessage.IShellMessage<T>,
      expectReply?: boolean,
      disposeOnDone?: boolean
    ): Kernel.IShellFuture<KernelMessage.IShellMessage<T>>;
    readonly status: Kernel.Status;
    readonly username: string;
  }
  export interface IManager extends IDisposable {
    connectionFailure: ISignal<IManager, ServerConnection.NetworkError>;
    connectTo(model: Kernel.IModel): IKernel;
    findById(id: string): Promise<IModel>;
    readonly isReady: boolean;
    readonly ready: Promise<void>;
    refreshRunning(): Promise<void>;
    refreshSpecs(): Promise<void>;
    running(): IIterator<IModel>;
    runningChanged: ISignal<IManager, IModel[]>;
    serverSettings?: ServerConnection.ISettings;
    shutdown(id: string): Promise<void>;
    shutdownAll(): Promise<void>;
    readonly specs: Kernel.ISpecModels | null;
    specsChanged: ISignal<IManager, ISpecModels>;
    startNew(options?: IOptions): Promise<IKernel>;
  }
  export interface IModel extends JSONObject {
    readonly id: string;
    readonly name: string;
  }
  export interface IOptions {
    clientId?: string;
    handleComms?: boolean;
    name?: string;
    serverSettings?: ServerConnection.ISettings;
    username?: string;
  }
  // (undocumented)
  export interface IShellFuture<
    REQUEST extends KernelMessage.IShellMessage = KernelMessage.IShellMessage,
    REPLY extends KernelMessage.IShellMessage = KernelMessage.IShellMessage
  > extends IFuture<REQUEST, REPLY> {}
  export interface ISpecModel extends JSONObject {
    readonly argv: string[];
    readonly display_name: string;
    readonly env?: JSONObject;
    readonly language: string;
    readonly metadata?: JSONObject;
    readonly name: string;
    readonly resources: {
      [key: string]: string;
    };
  }
  export interface ISpecModels extends JSONObject {
    default: string;
    readonly kernelspecs: {
      [key: string]: ISpecModel;
    };
  }
  export function listRunning(
    settings?: ServerConnection.ISettings
  ): Promise<Kernel.IModel[]>;
  export function shutdown(
    id: string,
    settings?: ServerConnection.ISettings
  ): Promise<void>;
  export function shutdownAll(
    settings?: ServerConnection.ISettings
  ): Promise<void>;
  export function startNew(options?: Kernel.IOptions): Promise<IKernel>;
  export type Status =
    | 'unknown'
    | 'starting'
    | 'reconnecting'
    | 'idle'
    | 'busy'
    | 'restarting'
    | 'autorestarting'
    | 'dead'
    | 'connected';
}

// @public
export class KernelManager implements Kernel.IManager {
  constructor(options?: KernelManager.IOptions);
  readonly connectionFailure: ISignal<this, Error>;
  connectTo(model: Kernel.IModel): Kernel.IKernel;
  dispose(): void;
  findById(id: string): Promise<Kernel.IModel>;
  readonly isDisposed: boolean;
  readonly isReady: boolean;
  readonly ready: Promise<void>;
  refreshRunning(): Promise<void>;
  refreshSpecs(): Promise<void>;
  protected requestRunning(): Promise<void>;
  protected requestSpecs(): Promise<void>;
  running(): IIterator<Kernel.IModel>;
  readonly runningChanged: ISignal<this, Kernel.IModel[]>;
  readonly serverSettings: ServerConnection.ISettings;
  shutdown(id: string): Promise<void>;
  shutdownAll(): Promise<void>;
  readonly specs: Kernel.ISpecModels | null;
  readonly specsChanged: ISignal<this, Kernel.ISpecModels>;
  startNew(options?: Kernel.IOptions): Promise<Kernel.IKernel>;
}

// @public
export namespace KernelManager {
  export interface IOptions {
    serverSettings?: ServerConnection.ISettings;
    standby?: Poll.Standby;
  }
}

// @public
export namespace KernelMessage {
  export type Channel = 'shell' | 'control' | 'iopub' | 'stdin';
  export type ControlMessageType = 'debug_request' | 'debug_reply';
  // (undocumented)
  export function createMessage<T extends IClearOutputMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends ICommCloseMsg<'iopub'>>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends ICommCloseMsg<'shell'>>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends ICommInfoReplyMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends ICommInfoRequestMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends ICommMsgMsg<'iopub'>>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends ICommMsgMsg<'shell'>>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends ICommOpenMsg<'iopub'>>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends ICommOpenMsg<'shell'>>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends ICompleteReplyMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends ICompleteRequestMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IDisplayDataMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IErrorMsg>(options: IOptions<T>): T;
  // (undocumented)
  export function createMessage<T extends IExecuteInputMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IExecuteReplyMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IExecuteRequestMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IExecuteResultMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IHistoryReplyMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IHistoryRequestMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IInfoReplyMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IInfoRequestMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IInputReplyMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IInputRequestMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IInspectReplyMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IInspectRequestMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IIsCompleteReplyMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IIsCompleteRequestMsg>(
    options: IOptions<T>
  ): T;
  // (undocumented)
  export function createMessage<T extends IStatusMsg>(options: IOptions<T>): T;
  // (undocumented)
  export function createMessage<T extends IStreamMsg>(options: IOptions<T>): T;
  // (undocumented)
  export function createMessage<T extends IUpdateDisplayDataMsg>(
    options: IOptions<T>
  ): T;
  export function createMessage<T extends IDebugRequestMsg>(
    options: IOptions<T>
  ): T;
  export function createMessage<T extends IDebugReplyMsg>(
    options: IOptions<T>
  ): T;
  export function createMessage<T extends IDebugEventMsg>(
    options: IOptions<T>
  ): T;
  export interface IClearOutputMsg extends IIOPubMessage<'clear_output'> {
    // (undocumented)
    content: {
      wait: boolean;
    };
  }
  export interface ICommCloseMsg<
    T extends 'iopub' | 'shell' = 'iopub' | 'shell'
  > extends IMessage<'comm_close'> {
    // (undocumented)
    channel: T;
    // (undocumented)
    content: {
      comm_id: string;
      data: JSONObject;
    };
  }
  export interface ICommInfoReply extends IReplyOkContent {
    comms: {
      [commId: string]: {
        target_name: string;
      };
    };
  }
  export interface ICommInfoReplyMsg extends IShellMessage<'comm_info_reply'> {
    // (undocumented)
    content: ReplyContent<ICommInfoReply>;
    // (undocumented)
    parent_header: IHeader<'comm_info_request'>;
  }
  export interface ICommInfoRequestMsg
    extends IShellMessage<'comm_info_request'> {
    // (undocumented)
    content: {
      target_name?: string;
      target?: string;
    };
  }
  export interface ICommMsgMsg<T extends 'iopub' | 'shell' = 'iopub' | 'shell'>
    extends IMessage<'comm_msg'> {
    // (undocumented)
    channel: T;
    // (undocumented)
    content: {
      comm_id: string;
      data: JSONObject;
    };
  }
  export interface ICommOpenMsg<
    T extends 'shell' | 'iopub' = 'iopub' | 'shell'
  > extends IMessage<'comm_open'> {
    // (undocumented)
    channel: T;
    // (undocumented)
    content: {
      comm_id: string;
      target_name: string;
      data: JSONObject;
      target_module?: string;
    };
  }
  export interface ICompleteReply extends IReplyOkContent {
    // (undocumented)
    cursor_end: number;
    // (undocumented)
    cursor_start: number;
    // (undocumented)
    matches: string[];
    // (undocumented)
    metadata: JSONObject;
  }
  export interface ICompleteReplyMsg extends IShellMessage<'complete_reply'> {
    // (undocumented)
    content: ReplyContent<ICompleteReply>;
    // (undocumented)
    parent_header: IHeader<'complete_request'>;
  }
  export interface ICompleteRequestMsg
    extends IShellMessage<'complete_request'> {
    // (undocumented)
    content: {
      code: string;
      cursor_pos: number;
    };
  }
  export interface IControlMessage<
    T extends ControlMessageType = ControlMessageType
  > extends IMessage<T> {
    // (undocumented)
    channel: 'control';
  }
  export interface IDebugEventMsg extends IIOPubMessage<'debug_event'> {
    // (undocumented)
    content: {
      seq: number;
      type: 'event';
      event: string;
      body?: any;
    };
  }
  export interface IDebugReplyMsg extends IControlMessage<'debug_reply'> {
    // (undocumented)
    content: {
      seq: number;
      type: 'response';
      request_seq: number;
      success: boolean;
      command: string;
      message?: string;
      body?: any;
    };
  }
  export interface IDebugRequestMsg extends IControlMessage<'debug_request'> {
    // (undocumented)
    content: {
      seq: number;
      type: 'request';
      command: string;
      arguments?: any;
    };
  }
  export interface IDisplayDataMsg extends IIOPubMessage<'display_data'> {
    // (undocumented)
    content: {
      data: nbformat.IMimeBundle;
      metadata: nbformat.OutputMetadata;
      transient?: {
        display_id?: string;
      };
    };
  }
  export interface IErrorMsg extends IIOPubMessage<'error'> {
    // (undocumented)
    content: {
      ename: string;
      evalue: string;
      traceback: string[];
    };
  }
  export interface IExecuteCount {
    // (undocumented)
    execution_count: nbformat.ExecutionCount;
  }
  export interface IExecuteInputMsg extends IIOPubMessage<'execute_input'> {
    // (undocumented)
    content: {
      code: string;
      execution_count: nbformat.ExecutionCount;
    };
  }
  export interface IExecuteReply extends IExecuteReplyBase {
    payload?: JSONObject[];
    user_expressions: JSONObject;
  }
  export type IExecuteReplyBase = IExecuteCount & IReplyOkContent;
  export interface IExecuteReplyMsg extends IShellMessage<'execute_reply'> {
    // (undocumented)
    content: ReplyContent<IExecuteReply> & IExecuteCount;
    // (undocumented)
    parent_header: IHeader<'execute_request'>;
  }
  export interface IExecuteRequestMsg extends IShellMessage<'execute_request'> {
    // (undocumented)
    content: {
      code: string;
      silent?: boolean;
      store_history?: boolean;
      user_expressions?: JSONObject;
      allow_stdin?: boolean;
      stop_on_error?: boolean;
    };
  }
  export interface IExecuteResultMsg extends IIOPubMessage<'execute_result'> {
    // (undocumented)
    content: {
      execution_count: nbformat.ExecutionCount;
      data: nbformat.IMimeBundle;
      metadata: nbformat.OutputMetadata;
      transient?: {
        display_id?: string;
      };
    };
  }
  export interface IHeader<T extends MessageType = MessageType> {
    date: string;
    msg_id: string;
    msg_type: T;
    session: string;
    username: string;
    version: string;
  }
  export interface IHistoryReply extends IReplyOkContent {
    // (undocumented)
    history: [number, number, string][] | [number, number, [string, string]][];
  }
  export interface IHistoryReplyMsg extends IShellMessage<'history_reply'> {
    // (undocumented)
    content: ReplyContent<IHistoryReply>;
    // (undocumented)
    parent_header: IHeader<'history_request'>;
  }
  export interface IHistoryRequestMsg extends IShellMessage<'history_request'> {
    // (undocumented)
    content: IHistoryRequestRange | IHistoryRequestSearch | IHistoryRequestTail;
  }
  export interface IHistoryRequestRange {
    // (undocumented)
    hist_access_type: 'range';
    // (undocumented)
    output: boolean;
    // (undocumented)
    raw: boolean;
    // (undocumented)
    session: number;
    // (undocumented)
    start: number;
    // (undocumented)
    stop: number;
  }
  export interface IHistoryRequestSearch {
    // (undocumented)
    hist_access_type: 'search';
    // (undocumented)
    n: number;
    // (undocumented)
    output: boolean;
    // (undocumented)
    pattern: string;
    // (undocumented)
    raw: boolean;
    // (undocumented)
    unique: boolean;
  }
  export interface IHistoryRequestTail {
    // (undocumented)
    hist_access_type: 'tail';
    // (undocumented)
    n: number;
    // (undocumented)
    output: boolean;
    // (undocumented)
    raw: boolean;
  }
  export interface IInfoReply extends IReplyOkContent {
    // (undocumented)
    banner: string;
    // (undocumented)
    help_links: {
      text: string;
      url: string;
    }[];
    // (undocumented)
    implementation: string;
    // (undocumented)
    implementation_version: string;
    // (undocumented)
    language_info: ILanguageInfo;
    // (undocumented)
    protocol_version: string;
  }
  export interface IInfoReplyMsg extends IShellMessage<'kernel_info_reply'> {
    // (undocumented)
    content: ReplyContent<IInfoReply>;
    // (undocumented)
    parent_header: IHeader<'kernel_info_request'>;
  }
  export interface IInfoRequestMsg
    extends IShellMessage<'kernel_info_request'> {
    // (undocumented)
    content: {};
  }
  export interface IInputReply extends IReplyOkContent {
    // (undocumented)
    value: string;
  }
  export interface IInputReplyMsg extends IStdinMessage<'input_reply'> {
    // (undocumented)
    content: ReplyContent<IInputReply>;
    // (undocumented)
    parent_header: IHeader<'input_request'>;
  }
  export interface IInputRequestMsg extends IStdinMessage<'input_request'> {
    // (undocumented)
    content: {
      prompt: string;
      password: boolean;
    };
  }
  export interface IInspectReply extends IReplyOkContent {
    // (undocumented)
    data: JSONObject;
    // (undocumented)
    found: boolean;
    // (undocumented)
    metadata: JSONObject;
  }
  export interface IInspectReplyMsg extends IShellMessage<'inspect_reply'> {
    // (undocumented)
    content: ReplyContent<IInspectReply>;
    // (undocumented)
    parent_header: IHeader<'inspect_request'>;
  }
  export interface IInspectRequestMsg extends IShellMessage<'inspect_request'> {
    // (undocumented)
    content: {
      code: string;
      cursor_pos: number;
      detail_level: 0 | 1;
    };
  }
  export interface IIOPubMessage<T extends IOPubMessageType = IOPubMessageType>
    extends IMessage<T> {
    // (undocumented)
    channel: 'iopub';
  }
  export interface IIsCompleteReplyIncomplete {
    // (undocumented)
    indent: string;
    // (undocumented)
    status: 'incomplete';
  }
  export interface IIsCompleteReplyMsg
    extends IShellMessage<'is_complete_reply'> {
    // (undocumented)
    content: ReplyContent<IIsCompleteReplyIncomplete | IIsCompleteReplyOther>;
    // (undocumented)
    parent_header: IHeader<'is_complete_request'>;
  }
  export interface IIsCompleteReplyOther {
    // (undocumented)
    status: 'complete' | 'invalid' | 'unknown';
  }
  export interface IIsCompleteRequestMsg
    extends IShellMessage<'is_complete_request'> {
    // (undocumented)
    content: {
      code: string;
    };
  }
  export interface ILanguageInfo extends nbformat.ILanguageInfoMetadata {
    // (undocumented)
    nbconverter_exporter?: string;
    // (undocumented)
    version: string;
  }
  export interface IMessage<MSGTYPE extends MessageType = MessageType> {
    buffers?: (ArrayBuffer | ArrayBufferView)[];
    channel: Channel;
    content: Message['content'];
    header: IHeader<MSGTYPE>;
    metadata: JSONObject;
    parent_header: IHeader | {};
  }
  // (undocumented)
  export interface IOptions<T extends Message> {
    // (undocumented)
    buffers?: (ArrayBuffer | ArrayBufferView)[];
    // (undocumented)
    channel: T['channel'];
    // (undocumented)
    content: T['content'];
    // (undocumented)
    metadata?: JSONObject;
    // (undocumented)
    msgId?: string;
    // (undocumented)
    msgType: T['header']['msg_type'];
    // (undocumented)
    parentHeader?: T['parent_header'];
    // (undocumented)
    session: string;
    // (undocumented)
    username?: string;
  }
  export type IOPubMessageType =
    | 'clear_output'
    | 'comm_close'
    | 'comm_msg'
    | 'comm_open'
    | 'display_data'
    | 'error'
    | 'execute_input'
    | 'execute_result'
    | 'status'
    | 'stream'
    | 'update_display_data'
    | 'debug_event';
  export interface IReplyAbortContent {
    // (undocumented)
    status: 'abort';
  }
  export interface IReplyErrorContent {
    ename: string;
    evalue: string;
    // (undocumented)
    status: 'error';
    traceback: string[];
  }
  export interface IReplyOkContent {
    // (undocumented)
    status: 'ok';
  }
  export function isClearOutputMsg(msg: IMessage): msg is IClearOutputMsg;
  export function isCommCloseMsg(
    msg: IMessage
  ): msg is ICommCloseMsg<'iopub' | 'shell'>;
  export function isCommMsgMsg(msg: IMessage): msg is ICommMsgMsg;
  export function isCommOpenMsg(msg: IMessage): msg is ICommOpenMsg;
  export function isDebugEventMsg(msg: IMessage): msg is IDebugEventMsg;
  export function isDebugReplyMsg(msg: IMessage): msg is IDebugReplyMsg;
  export function isDebugRequestMsg(msg: IMessage): msg is IDebugRequestMsg;
  export function isDisplayDataMsg(msg: IMessage): msg is IDisplayDataMsg;
  export function isErrorMsg(msg: IMessage): msg is IErrorMsg;
  export function isExecuteInputMsg(msg: IMessage): msg is IExecuteInputMsg;
  export function isExecuteReplyMsg(msg: IMessage): msg is IExecuteReplyMsg;
  export function isExecuteResultMsg(msg: IMessage): msg is IExecuteResultMsg;
  export type IShellControlMessage = IShellMessage | IControlMessage;
  export interface IShellMessage<T extends ShellMessageType = ShellMessageType>
    extends IMessage<T> {
    // (undocumented)
    channel: 'shell';
  }
  export function isInfoRequestMsg(msg: IMessage): msg is IInfoRequestMsg;
  export function isInputReplyMsg(msg: IMessage): msg is IInputReplyMsg;
  export function isInputRequestMsg(msg: IMessage): msg is IInputRequestMsg;
  export function isStatusMsg(msg: IMessage): msg is IStatusMsg;
  export function isStreamMsg(msg: IMessage): msg is IStreamMsg;
  export interface IStatusMsg extends IIOPubMessage<'status'> {
    // (undocumented)
    content: {
      execution_state: Kernel.Status;
    };
  }
  export interface IStdinMessage<T extends StdinMessageType = StdinMessageType>
    extends IMessage<T> {
    // (undocumented)
    channel: 'stdin';
  }
  export interface IStreamMsg extends IIOPubMessage<'stream'> {
    // (undocumented)
    content: {
      name: 'stdout' | 'stderr';
      text: string;
    };
  }
  export function isUpdateDisplayDataMsg(
    msg: IMessage
  ): msg is IUpdateDisplayDataMsg;
  export interface IUpdateDisplayDataMsg
    extends IIOPubMessage<'update_display_data'> {
    // (undocumented)
    content: IDisplayDataMsg['content'] & {
      transient: {
        display_id: string;
      };
    };
  }
  export type Message =
    | IClearOutputMsg
    | ICommCloseMsg<'iopub'>
    | ICommCloseMsg<'shell'>
    | ICommInfoReplyMsg
    | ICommInfoRequestMsg
    | ICommMsgMsg<'iopub'>
    | ICommMsgMsg<'shell'>
    | ICommOpenMsg<'iopub'>
    | ICommOpenMsg<'shell'>
    | ICompleteReplyMsg
    | ICompleteRequestMsg
    | IDisplayDataMsg
    | IErrorMsg
    | IExecuteInputMsg
    | IExecuteReplyMsg
    | IExecuteRequestMsg
    | IExecuteResultMsg
    | IHistoryReplyMsg
    | IHistoryRequestMsg
    | IInfoReplyMsg
    | IInfoRequestMsg
    | IInputReplyMsg
    | IInputRequestMsg
    | IInspectReplyMsg
    | IInspectRequestMsg
    | IIsCompleteReplyMsg
    | IIsCompleteRequestMsg
    | IStatusMsg
    | IStreamMsg
    | IUpdateDisplayDataMsg
    | IDebugRequestMsg
    | IDebugReplyMsg
    | IDebugEventMsg;
  export type MessageType =
    | IOPubMessageType
    | ShellMessageType
    | ControlMessageType
    | StdinMessageType;
  export type ReplyContent<T> = T | IReplyErrorContent | IReplyAbortContent;
  export type ShellMessageType =
    | 'comm_close'
    | 'comm_info_reply'
    | 'comm_info_request'
    | 'comm_msg'
    | 'comm_open'
    | 'complete_reply'
    | 'complete_request'
    | 'execute_reply'
    | 'execute_request'
    | 'history_reply'
    | 'history_request'
    | 'inspect_reply'
    | 'inspect_request'
    | 'interrupt_reply'
    | 'interrupt_request'
    | 'is_complete_reply'
    | 'is_complete_request'
    | 'kernel_info_reply'
    | 'kernel_info_request'
    | 'shutdown_reply'
    | 'shutdown_request';
  export type StdinMessageType = 'input_request' | 'input_reply';
}

// @public
export namespace NbConvert {
  export interface IManager extends NbConvertManager {}
}

// @public
export class NbConvertManager {
  constructor(options?: NbConvertManager.IOptions);
  getExportFormats(): Promise<NbConvertManager.IExportFormats>;
  readonly serverSettings: ServerConnection.ISettings;
}

// @public
export namespace NbConvertManager {
  export interface IExportFormats {
    [key: string]: {
      output_mimetype: string;
    };
  }
  export interface IOptions {
    serverSettings?: ServerConnection.ISettings;
  }
}

// @public
export namespace ServerConnection {
  export interface ISettings {
    readonly appUrl: string;
    readonly baseUrl: string;
    readonly fetch: (
      input: RequestInfo,
      init?: RequestInit
    ) => Promise<Response>;
    readonly Headers: typeof Headers;
    readonly init: RequestInit;
    readonly Request: typeof Request;
    readonly token: string;
    readonly WebSocket: typeof WebSocket;
    readonly wsUrl: string;
  }
  export function makeRequest(
    url: string,
    init: RequestInit,
    settings: ISettings
  ): Promise<Response>;
  export function makeSettings(options?: Partial<ISettings>): ISettings;
  export class NetworkError extends TypeError {
    constructor(original: TypeError);
  }
  export class ResponseError extends Error {
    constructor(response: Response, message?: string);
    response: Response;
  }
  const defaultSettings: ServerConnection.ISettings;
}

// @public
export class ServiceManager implements ServiceManager.IManager {
  constructor(options?: ServiceManager.IOptions);
  readonly builder: BuildManager;
  readonly connectionFailure: ISignal<this, Error>;
  readonly contents: ContentsManager;
  dispose(): void;
  readonly isDisposed: boolean;
  readonly isReady: boolean;
  readonly nbconvert: NbConvertManager;
  readonly ready: Promise<void>;
  readonly serverSettings: ServerConnection.ISettings;
  readonly sessions: SessionManager;
  readonly settings: SettingManager;
  readonly specs: Kernel.ISpecModels | null;
  readonly specsChanged: ISignal<this, Kernel.ISpecModels>;
  readonly terminals: TerminalManager;
  readonly workspaces: WorkspaceManager;
}

// @public
export namespace ServiceManager {
  export interface IManager extends IDisposable {
    readonly builder: Builder.IManager;
    readonly connectionFailure: ISignal<IManager, Error>;
    readonly contents: Contents.IManager;
    readonly isReady: boolean;
    readonly nbconvert: NbConvert.IManager;
    readonly ready: Promise<void>;
    readonly serverSettings: ServerConnection.ISettings;
    readonly sessions: Session.IManager;
    readonly settings: Setting.IManager;
    readonly specs: Kernel.ISpecModels | null;
    readonly specsChanged: ISignal<IManager, Kernel.ISpecModels>;
    readonly terminals: TerminalSession.IManager;
    readonly workspaces: Workspace.IManager;
  }
  export interface IOptions {
    readonly defaultDrive?: Contents.IDrive;
    readonly serverSettings?: ServerConnection.ISettings;
    standby?: Poll.Standby;
  }
}

// @public
export namespace Session {
  export function connectTo(
    model: Session.IModel,
    settings?: ServerConnection.ISettings
  ): ISession;
  export function findById(
    id: string,
    settings?: ServerConnection.ISettings
  ): Promise<Session.IModel>;
  export function findByPath(
    path: string,
    settings?: ServerConnection.ISettings
  ): Promise<Session.IModel>;
  export interface IKernelChangedArgs {
    newValue: Kernel.IKernelConnection | null;
    oldValue: Kernel.IKernelConnection | null;
  }
  export interface IManager extends IDisposable {
    connectionFailure: ISignal<IManager, ServerConnection.NetworkError>;
    connectTo(model: Session.IModel): ISession;
    findById(id: string): Promise<IModel>;
    findByPath(path: string): Promise<IModel>;
    readonly isReady: boolean;
    readonly ready: Promise<void>;
    refreshRunning(): Promise<void>;
    refreshSpecs(): Promise<void>;
    running(): IIterator<IModel>;
    runningChanged: ISignal<this, IModel[]>;
    serverSettings?: ServerConnection.ISettings;
    shutdown(id: string): Promise<void>;
    shutdownAll(): Promise<void>;
    readonly specs: Kernel.ISpecModels | null;
    specsChanged: ISignal<this, Kernel.ISpecModels>;
    startNew(options: IOptions): Promise<ISession>;
    stopIfNeeded(path: string): Promise<void>;
  }
  export interface IModel extends JSONObject {
    readonly id: string;
    // (undocumented)
    readonly kernel: Kernel.IModel;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly path: string;
    // (undocumented)
    readonly type: string;
  }
  export interface IOptions {
    clientId?: string;
    kernelId?: string;
    kernelName?: string;
    name?: string;
    path: string;
    serverSettings?: ServerConnection.ISettings;
    type?: string;
    username?: string;
  }
  export interface ISession extends IDisposable {
    anyMessage: ISignal<this, Kernel.IAnyMessageArgs>;
    changeKernel(
      options: Partial<Kernel.IModel>
    ): Promise<Kernel.IKernelConnection>;
    readonly id: string;
    iopubMessage: ISignal<this, KernelMessage.IIOPubMessage>;
    readonly kernel: Kernel.IKernelConnection;
    kernelChanged: ISignal<this, IKernelChangedArgs>;
    readonly model: Session.IModel;
    readonly name: string;
    readonly path: string;
    readonly propertyChanged: ISignal<this, 'path' | 'name' | 'type'>;
    readonly serverSettings: ServerConnection.ISettings;
    setName(name: string): Promise<void>;
    setPath(path: string): Promise<void>;
    setType(type: string): Promise<void>;
    shutdown(): Promise<void>;
    readonly status: Kernel.Status;
    statusChanged: ISignal<this, Kernel.Status>;
    terminated: ISignal<this, void>;
    readonly type: string;
    unhandledMessage: ISignal<this, KernelMessage.IMessage>;
  }
  export function listRunning(
    settings?: ServerConnection.ISettings
  ): Promise<Session.IModel[]>;
  export function shutdown(
    id: string,
    settings?: ServerConnection.ISettings
  ): Promise<void>;
  export function shutdownAll(
    settings?: ServerConnection.ISettings
  ): Promise<void>;
  export function startNew(options: Session.IOptions): Promise<ISession>;
}

// @public
export class SessionManager implements Session.IManager {
  constructor(options?: SessionManager.IOptions);
  readonly connectionFailure: ISignal<this, Error>;
  // (undocumented)
  connectTo(model: Session.IModel): Session.ISession;
  dispose(): void;
  findById(id: string): Promise<Session.IModel>;
  findByPath(path: string): Promise<Session.IModel>;
  readonly isDisposed: boolean;
  readonly isReady: boolean;
  readonly ready: Promise<void>;
  refreshRunning(): Promise<void>;
  refreshSpecs(): Promise<void>;
  protected requestRunning(): Promise<void>;
  protected requestSpecs(): Promise<void>;
  running(): IIterator<Session.IModel>;
  readonly runningChanged: ISignal<this, Session.IModel[]>;
  readonly serverSettings: ServerConnection.ISettings;
  shutdown(id: string): Promise<void>;
  shutdownAll(): Promise<void>;
  readonly specs: Kernel.ISpecModels | null;
  readonly specsChanged: ISignal<this, Kernel.ISpecModels>;
  startNew(options: Session.IOptions): Promise<Session.ISession>;
  stopIfNeeded(path: string): Promise<void>;
}

// @public
export namespace SessionManager {
  export interface IOptions {
    serverSettings?: ServerConnection.ISettings;
    standby?: Poll.Standby;
  }
}

// @public
export namespace Setting {
  export interface IManager extends SettingManager {}
}

// @public
export class SettingManager extends DataConnector<
  ISettingRegistry.IPlugin,
  string
> {
  constructor(options?: SettingManager.IOptions);
  fetch(id: string): Promise<ISettingRegistry.IPlugin>;
  list(): Promise<{
    ids: string[];
    values: ISettingRegistry.IPlugin[];
  }>;
  save(id: string, raw: string): Promise<void>;
  readonly serverSettings: ServerConnection.ISettings;
}

// @public
export namespace SettingManager {
  export interface IOptions {
    serverSettings?: ServerConnection.ISettings;
  }
}

// @public
export class TerminalManager implements TerminalSession.IManager {
  constructor(options?: TerminalManager.IOptions);
  readonly connectionFailure: ISignal<this, Error>;
  // (undocumented)
  connectTo(
    name: string,
    options?: TerminalSession.IOptions
  ): Promise<TerminalSession.ISession>;
  dispose(): void;
  isAvailable(): boolean;
  readonly isDisposed: boolean;
  readonly isReady: boolean;
  readonly ready: Promise<void>;
  refreshRunning(): Promise<void>;
  protected requestRunning(): Promise<void>;
  running(): IIterator<TerminalSession.IModel>;
  readonly runningChanged: ISignal<this, TerminalSession.IModel[]>;
  readonly serverSettings: ServerConnection.ISettings;
  shutdown(name: string): Promise<void>;
  shutdownAll(): Promise<void>;
  startNew(
    options?: TerminalSession.IOptions
  ): Promise<TerminalSession.ISession>;
}

// @public
export namespace TerminalManager {
  export interface IOptions {
    serverSettings?: ServerConnection.ISettings;
    standby?: Poll.Standby;
  }
}

// @public
export namespace TerminalSession {
  // (undocumented)
  export function connectTo(
    name: string,
    options?: IOptions
  ): Promise<ISession>;
  export interface IManager extends IDisposable {
    connectionFailure: ISignal<IManager, ServerConnection.NetworkError>;
    // (undocumented)
    connectTo(name: string): Promise<ISession>;
    isAvailable(): boolean;
    readonly isReady: boolean;
    readonly ready: Promise<void>;
    refreshRunning(): Promise<void>;
    running(): IIterator<IModel>;
    runningChanged: ISignal<IManager, IModel[]>;
    readonly serverSettings: ServerConnection.ISettings;
    shutdown(name: string): Promise<void>;
    shutdownAll(): Promise<void>;
    startNew(options?: IOptions): Promise<ISession>;
  }
  export interface IMessage {
    readonly content?: JSONPrimitive[];
    readonly type: MessageType;
  }
  export interface IModel extends JSONObject {
    readonly name: string;
  }
  export interface IOptions {
    serverSettings?: ServerConnection.ISettings;
  }
  export function isAvailable(): boolean;
  export interface ISession extends IDisposable {
    readonly isReady: boolean;
    messageReceived: ISignal<ISession, IMessage>;
    readonly model: IModel;
    readonly name: string;
    readonly ready: Promise<void>;
    reconnect(): Promise<void>;
    send(message: IMessage): void;
    readonly serverSettings: ServerConnection.ISettings;
    shutdown(): Promise<void>;
    terminated: ISignal<ISession, void>;
  }
  export function listRunning(
    settings?: ServerConnection.ISettings
  ): Promise<IModel[]>;
  export type MessageType = 'stdout' | 'disconnect' | 'set_size' | 'stdin';
  export function shutdown(
    name: string,
    settings?: ServerConnection.ISettings
  ): Promise<void>;
  export function shutdownAll(
    settings?: ServerConnection.ISettings
  ): Promise<void>;
  export function startNew(options?: IOptions): Promise<ISession>;
}

// @public
export namespace Workspace {
  export interface IManager extends WorkspaceManager {}
  export interface IWorkspace {
    data: ReadonlyJSONObject;
    metadata: {
      id: string;
    };
  }
}

// @public
export class WorkspaceManager extends DataConnector<Workspace.IWorkspace> {
  constructor(options?: WorkspaceManager.IOptions);
  fetch(id: string): Promise<Workspace.IWorkspace>;
  list(): Promise<{
    ids: string[];
    values: Workspace.IWorkspace[];
  }>;
  remove(id: string): Promise<void>;
  save(id: string, workspace: Workspace.IWorkspace): Promise<void>;
  readonly serverSettings: ServerConnection.ISettings;
}

// @public
export namespace WorkspaceManager {
  export interface IOptions {
    serverSettings?: ServerConnection.ISettings;
  }
}

// (No @packageDocumentation comment for this package)
```
