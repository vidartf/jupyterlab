## API Report File for "@jupyterlab/filebrowser"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { Contents } from '@jupyterlab/services';
import { Dialog } from '@jupyterlab/apputils';
import { DocumentRegistry } from '@jupyterlab/docregistry';
import { IChangedArgs } from '@jupyterlab/coreutils';
import { IDisposable } from '@phosphor/disposable';
import { IDocumentManager } from '@jupyterlab/docmanager';
import { IIconRegistry } from '@jupyterlab/ui-components';
import { IIterator } from '@phosphor/algorithm';
import { ISignal } from '@phosphor/signaling';
import { IStateDB } from '@jupyterlab/coreutils';
import { Kernel } from '@jupyterlab/services';
import { Message } from '@phosphor/messaging';
import { Session } from '@jupyterlab/services';
import { Token } from '@phosphor/coreutils';
import { Toolbar } from '@jupyterlab/apputils';
import { ToolbarButton } from '@jupyterlab/apputils';
import { VDomModel } from '@jupyterlab/apputils';
import { VDomRenderer } from '@jupyterlab/apputils';
import { Widget } from '@phosphor/widgets';
import { WidgetTracker } from '@jupyterlab/apputils';

// @public
export class BreadCrumbs extends Widget {
  constructor(options: BreadCrumbs.IOptions);
  handleEvent(event: Event): void;
  protected onAfterAttach(msg: Message): void;
  protected onBeforeDetach(msg: Message): void;
  protected onUpdateRequest(msg: Message): void;
}

// @public
export namespace BreadCrumbs {
  export interface IOptions {
    model: FileBrowserModel;
  }
}

// @public
export const CHUNK_SIZE: number;

// @public
export class DirListing extends Widget {
  constructor(options: DirListing.IOptions);
  clearSelectedItems(): void;
  readonly contentNode: HTMLElement;
  copy(): void;
  cut(): void;
  delete(): Promise<void>;
  dispose(): void;
  download(): Promise<void>;
  duplicate(): Promise<void>;
  handleEvent(event: Event): void;
  readonly headerNode: HTMLElement;
  isSelected(name: string): boolean;
  readonly model: FileBrowserModel;
  modelForClick(event: MouseEvent): Contents.IModel | undefined;
  protected onAfterAttach(msg: Message): void;
  protected onAfterShow(msg: Message): void;
  protected onBeforeDetach(msg: Message): void;
  readonly onItemOpened: ISignal<DirListing, Contents.IModel>;
  // (undocumented)
  onResize(msg: Widget.ResizeMessage): void;
  protected onUpdateRequest(msg: Message): void;
  paste(): Promise<void>;
  rename(): Promise<string>;
  readonly renderer: DirListing.IRenderer;
  selectByPrefix(): void;
  selectedItems(): IIterator<Contents.IModel>;
  selectItemByName(name: string): Promise<void>;
  selectNext(keepExisting?: boolean): void;
  selectPrevious(keepExisting?: boolean): void;
  shutdownKernels(): Promise<void>;
  sort(state: DirListing.ISortState): void;
  sortedItems(): IIterator<Contents.IModel>;
  readonly sortState: DirListing.ISortState;
}

// @public
export namespace DirListing {
  export interface IContentsThunk {
    model: Contents.IModel;
    withContent: () => Promise<Contents.IModel>;
  }
  export interface IOptions {
    model: FileBrowserModel;
    renderer?: IRenderer;
  }
  export interface IRenderer {
    createDragImage(
      node: HTMLElement,
      count: number,
      fileType?: DocumentRegistry.IFileType
    ): HTMLElement;
    createItemNode(): HTMLElement;
    createNode(): HTMLElement;
    getNameNode(node: HTMLElement): HTMLElement;
    handleHeaderClick(node: HTMLElement, event: MouseEvent): ISortState;
    populateHeaderNode(node: HTMLElement): void;
    updateItemNode(
      node: HTMLElement,
      model: Contents.IModel,
      fileType?: DocumentRegistry.IFileType
    ): void;
  }
  export interface ISortState {
    direction: 'ascending' | 'descending';
    key: 'name' | 'last_modified';
  }
  export class Renderer implements IRenderer {
    constructor(icoReg: IIconRegistry);
    createDragImage(
      node: HTMLElement,
      count: number,
      fileType?: DocumentRegistry.IFileType
    ): HTMLElement;
    createItemNode(): HTMLElement;
    createNode(): HTMLElement;
    getNameNode(node: HTMLElement): HTMLElement;
    handleHeaderClick(node: HTMLElement, event: MouseEvent): ISortState;
    // (undocumented)
    _iconRegistry: IIconRegistry;
    populateHeaderNode(node: HTMLElement): void;
    updateItemNode(
      node: HTMLElement,
      model: Contents.IModel,
      fileType?: DocumentRegistry.IFileType
    ): void;
  }
}

// @public
export class FileBrowser extends Widget {
  constructor(options: FileBrowser.IOptions);
  // (undocumented)
  clearSelectedItems(): void;
  copy(): void;
  createNewDirectory(): void;
  cut(): void;
  delete(): Promise<void>;
  download(): Promise<void>;
  duplicate(): Promise<void>;
  readonly model: FileBrowserModel;
  modelForClick(event: MouseEvent): Contents.IModel | undefined;
  navigateToCurrentDirectory: boolean;
  paste(): Promise<void>;
  rename(): Promise<string>;
  selectedItems(): IIterator<Contents.IModel>;
  selectItemByName(name: string): Promise<void>;
  selectNext(): void;
  selectPrevious(): void;
  shutdownKernels(): Promise<void>;
  readonly toolbar: Toolbar<Widget>;
}

// @public
export namespace FileBrowser {
  export interface IOptions {
    id: string;
    model: FileBrowserModel;
    renderer?: DirListing.IRenderer;
  }
}

// @public
export class FileBrowserModel implements IDisposable {
  constructor(options: FileBrowserModel.IOptions);
  cd(newValue?: string): Promise<void>;
  readonly connectionFailure: ISignal<this, Error>;
  dispose(): void;
  download(path: string): Promise<void>;
  readonly driveName: string;
  readonly fileChanged: ISignal<this, Contents.IChangedArgs>;
  readonly iconRegistry: IIconRegistry;
  readonly isDisposed: boolean;
  items(): IIterator<Contents.IModel>;
  readonly manager: IDocumentManager;
  readonly path: string;
  readonly pathChanged: ISignal<this, IChangedArgs<string>>;
  refresh(): Promise<void>;
  readonly refreshed: ISignal<this, void>;
  restore(id: string): Promise<void>;
  readonly restored: Promise<void>;
  sessions(): IIterator<Session.IModel>;
  readonly specs: Kernel.ISpecModels | null;
  upload(file: File): Promise<Contents.IModel>;
  readonly uploadChanged: ISignal<this, IChangedArgs<IUploadModel>>;
  uploads(): IIterator<IUploadModel>;
}

// @public
export namespace FileBrowserModel {
  export interface IOptions {
    driveName?: string;
    iconRegistry: IIconRegistry;
    manager: IDocumentManager;
    refreshInterval?: number;
    state?: IStateDB;
  }
}

// @public
export namespace FileDialog {
  export function getExistingDirectory(
    options: IDirectoryOptions
  ): Promise<Dialog.IResult<Contents.IModel[]>>;
  export function getOpenFiles(
    options: IFileOptions
  ): Promise<Dialog.IResult<Contents.IModel[]>>;
  export interface IDirectoryOptions
    extends Partial<
      Pick<
        Dialog.IOptions<Promise<Contents.IModel[]>>,
        Exclude<
          keyof Dialog.IOptions<Promise<Contents.IModel[]>>,
          'body' | 'buttons' | 'defaultButton'
        >
      >
    > {
    iconRegistry: IIconRegistry;
    manager: IDocumentManager;
  }
  export interface IFileOptions extends IDirectoryOptions {
    filter?: (value: Contents.IModel) => boolean;
  }
}

// @public
export class FileUploadStatus extends VDomRenderer<FileUploadStatus.Model> {
  constructor(opts: FileUploadStatus.IOptions);
  // (undocumented)
  dispose(): void;
  render(): JSX.Element;
}

// @public
export namespace FileUploadStatus {
  export interface IOptions {
    readonly tracker: WidgetTracker<FileBrowser>;
  }
  export class Model extends VDomModel {
    constructor(browserModel: FileBrowserModel | null);
    browserModel: FileBrowserModel | null;
    // Warning: (ae-forgotten-export) The symbol "IFileUploadItem" needs to be exported by the entry point index.d.ts
    readonly items: IFileUploadItem[];
  }
}

// @public
export class FilterFileBrowserModel extends FileBrowserModel {
  constructor(options: FilterFileBrowserModel.IOptions);
  items(): IIterator<Contents.IModel>;
}

// @public
export namespace FilterFileBrowserModel {
  export interface IOptions extends FileBrowserModel.IOptions {
    filter?: (value: Contents.IModel) => boolean;
  }
}

// @public
export const IFileBrowserFactory: Token<IFileBrowserFactory>;

// @public
export interface IFileBrowserFactory {
  createFileBrowser(
    id: string,
    options?: IFileBrowserFactory.IOptions
  ): FileBrowser;
  defaultBrowser: FileBrowser;
  readonly tracker: WidgetTracker<FileBrowser>;
}

// @public
export namespace IFileBrowserFactory {
  export interface IOptions {
    driveName?: string;
    refreshInterval?: number;
    state?: IStateDB | null;
  }
}

// @public
export interface IUploadModel {
  // (undocumented)
  path: string;
  progress: number;
}

// @public
export const LARGE_FILE_SIZE: number;

// @public
export class Uploader extends ToolbarButton {
  constructor(options: Uploader.IOptions);
  readonly fileBrowserModel: FileBrowserModel;
}

// @public
export namespace Uploader {
  export interface IOptions {
    model: FileBrowserModel;
  }
}

// (No @packageDocumentation comment for this package)
```
