## API Report File for "@jupyterlab/completer"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { CodeEditor } from '@jupyterlab/codeeditor';
import { DataConnector } from '@jupyterlab/coreutils';
import { IClientSession } from '@jupyterlab/apputils';
import { IDataConnector } from '@jupyterlab/coreutils';
import { IDisposable } from '@phosphor/disposable';
import { IIterator } from '@phosphor/algorithm';
import { ISignal } from '@phosphor/signaling';
import { IterableOrArrayLike } from '@phosphor/algorithm';
import { JSONObject } from '@phosphor/coreutils';
import { Message } from '@phosphor/messaging';
import { ReadonlyJSONObject } from '@phosphor/coreutils';
import { Session } from '@jupyterlab/services';
import { Token } from '@phosphor/coreutils';
import { Widget } from '@phosphor/widgets';

// @public
export class Completer extends Widget {
  constructor(options: Completer.IOptions);
  dispose(): void;
  editor: CodeEditor.IEditor | null;
  handleEvent(event: Event): void;
  model: Completer.IModel | null;
  protected onAfterAttach(msg: Message): void;
  protected onBeforeDetach(msg: Message): void;
  protected onModelStateChanged(): void;
  protected onUpdateRequest(msg: Message): void;
  reset(): void;
  selectActive(): void;
  readonly selected: ISignal<this, string>;
  readonly visibilityChanged: ISignal<this, void>;
}

// @public (undocumented)
export namespace Completer {
  export interface ICursorSpan extends JSONObject {
    end: number;
    start: number;
  }
  export interface IItem {
    raw: string;
    text: string;
  }
  export interface IModel extends IDisposable {
    createPatch(patch: string): IPatch | undefined;
    current: ITextState | null;
    cursor: ICursorSpan | null;
    handleCursorChange(change: Completer.ITextState): void;
    handleTextChange(change: Completer.ITextState): void;
    items(): IIterator<IItem>;
    options(): IIterator<string>;
    orderedTypes(): string[];
    original: ITextState | null;
    query: string;
    reset(hard?: boolean): void;
    setOptions(
      options: IterableOrArrayLike<string>,
      typeMap?: JSONObject
    ): void;
    readonly stateChanged: ISignal<IModel, void>;
    subsetMatch: boolean;
    typeMap(): TypeMap;
  }
  export interface IOptions {
    editor?: CodeEditor.IEditor | null;
    model?: IModel;
    renderer?: IRenderer;
  }
  export interface IPatch {
    end: number;
    start: number;
    value: string;
  }
  export interface IRenderer {
    createItemNode(
      item: IItem,
      typeMap: TypeMap,
      orderedTypes: string[]
    ): HTMLLIElement;
  }
  export interface ITextState extends JSONObject {
    readonly charWidth: number;
    readonly column: number;
    readonly line: number;
    readonly lineHeight: number;
    readonly text: string;
  }
  export class Renderer implements IRenderer {
    createItemNode(
      item: IItem,
      typeMap: TypeMap,
      orderedTypes: string[]
    ): HTMLLIElement;
  }
  export type TypeMap = {
    [index: string]: string;
  };
  const defaultRenderer: Renderer;
}

// @public
export class CompleterModel implements Completer.IModel {
  createPatch(patch: string): Completer.IPatch | undefined;
  current: Completer.ITextState | null;
  cursor: Completer.ICursorSpan | null;
  dispose(): void;
  handleCursorChange(change: Completer.ITextState): void;
  handleTextChange(change: Completer.ITextState): void;
  readonly isDisposed: boolean;
  items(): IIterator<Completer.IItem>;
  options(): IIterator<string>;
  orderedTypes(): string[];
  original: Completer.ITextState | null;
  query: string;
  reset(hard?: boolean): void;
  setOptions(
    newValue: IterableOrArrayLike<string>,
    typeMap?: Completer.TypeMap
  ): void;
  readonly stateChanged: ISignal<this, void>;
  subsetMatch: boolean;
  typeMap(): Completer.TypeMap;
}

// @public
export class CompletionConnector extends DataConnector<
  CompletionHandler.IReply,
  void,
  CompletionHandler.IRequest
> {
  constructor(options: CompletionConnector.IOptions);
  fetch(request: CompletionHandler.IRequest): Promise<CompletionHandler.IReply>;
}

// @public
export namespace CompletionConnector {
  export type IOptions = KernelConnector.IOptions & ContextConnector.IOptions;
}

// @public
export class CompletionHandler implements IDisposable {
  constructor(options: CompletionHandler.IOptions);
  readonly completer: Completer;
  connector: IDataConnector<
    CompletionHandler.IReply,
    void,
    CompletionHandler.IRequest
  >;
  dispose(): void;
  editor: CodeEditor.IEditor | null;
  protected getState(
    editor: CodeEditor.IEditor,
    position: CodeEditor.IPosition
  ): Completer.ITextState;
  invoke(): void;
  readonly isDisposed: boolean;
  protected onCompletionSelected(completer: Completer, val: string): void;
  protected onInvokeRequest(msg: Message): void;
  protected onSelectionsChanged(): void;
  protected onTextChanged(): void;
  protected onVisibilityChanged(completer: Completer): void;
  processMessage(msg: Message): void;
}

// @public
export namespace CompletionHandler {
  export interface IOptions {
    completer: Completer;
    connector: IDataConnector<IReply, void, IRequest>;
  }
  export interface IReply {
    end: number;
    matches: ReadonlyArray<string>;
    metadata: ReadonlyJSONObject;
    start: number;
  }
  export interface IRequest {
    offset: number;
    text: string;
  }
  export namespace Msg {
    const InvokeRequest: Message;
  }
}

// @public
export class ContextConnector extends DataConnector<
  CompletionHandler.IReply,
  void,
  CompletionHandler.IRequest
> {
  constructor(options: ContextConnector.IOptions);
  fetch(request: CompletionHandler.IRequest): Promise<CompletionHandler.IReply>;
}

// @public
export namespace ContextConnector {
  export interface IOptions {
    editor: CodeEditor.IEditor;
  }
}

// @public
export const ICompletionManager: Token<ICompletionManager>;

// @public
export interface ICompletionManager {
  register(
    completable: ICompletionManager.ICompletable
  ): ICompletionManager.ICompletableAttributes;
}

// @public
export namespace ICompletionManager {
  export interface ICompletable extends ICompletableAttributes {
    readonly parent: Widget;
  }
  export interface ICompletableAttributes {
    connector: IDataConnector<
      CompletionHandler.IReply,
      void,
      CompletionHandler.IRequest
    >;
    editor: CodeEditor.IEditor | null;
  }
}

// @public
export class KernelConnector extends DataConnector<
  CompletionHandler.IReply,
  void,
  CompletionHandler.IRequest
> {
  constructor(options: KernelConnector.IOptions);
  fetch(request: CompletionHandler.IRequest): Promise<CompletionHandler.IReply>;
}

// @public
export namespace KernelConnector {
  export interface IOptions {
    session: IClientSession | Session.ISession;
  }
}

// (No @packageDocumentation comment for this package)
```
