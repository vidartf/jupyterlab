## API Report File for "@jupyterlab/codemirror"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { CodeEditor } from '@jupyterlab/codeeditor';
import CodeMirror from 'codemirror';
import { CommandRegistry } from '@phosphor/commands';
import { IDisposable } from '@phosphor/disposable';
import { IEditorFactoryService } from '@jupyterlab/codeeditor';
import { IEditorMimeTypeService } from '@jupyterlab/codeeditor';
import { IEditorServices } from '@jupyterlab/codeeditor';
import { JSONValue } from '@phosphor/coreutils';
import { nbformat } from '@jupyterlab/coreutils';
import { Signal } from '@phosphor/signaling';
import { VDomModel } from '@jupyterlab/apputils';
import { VDomRenderer } from '@jupyterlab/apputils';

// @public
export class CodeMirrorEditor implements CodeEditor.IEditor {
  constructor(options: CodeMirrorEditor.IOptions);
  addKeydownHandler(handler: CodeEditor.KeydownHandler): IDisposable;
  // (undocumented)
  addOverlay(mode: string | object, options?: object): void;
  blur(): void;
  readonly charWidth: number;
  clearHistory(): void;
  // (undocumented)
  cursorCoords(
    where: boolean,
    mode?: 'window' | 'page' | 'local'
  ): {
    left: number;
    top: number;
    bottom: number;
  };
  dispose(): void;
  readonly doc: CodeMirror.Doc;
  readonly edgeRequested: Signal<this, CodeEditor.EdgeLocation>;
  readonly editor: CodeMirror.Editor;
  execCommand(command: string): void;
  // (undocumented)
  firstLine(): number;
  focus(): void;
  getCoordinateForPosition(
    position: CodeEditor.IPosition
  ): CodeEditor.ICoordinate;
  // (undocumented)
  getCursor(start?: string): CodeMirror.Position;
  getCursorPosition(): CodeEditor.IPosition;
  getLine(line: number): string | undefined;
  getOffsetAt(position: CodeEditor.IPosition): number;
  getOption<K extends keyof CodeMirrorEditor.IConfig>(
    option: K
  ): CodeMirrorEditor.IConfig[K];
  getPositionAt(offset: number): CodeEditor.IPosition;
  getPositionForCoordinate(
    coordinate: CodeEditor.ICoordinate
  ): CodeEditor.IPosition | null;
  // (undocumented)
  getRange(
    from: CodeMirror.Position,
    to: CodeMirror.Position,
    seperator?: string
  ): string;
  // (undocumented)
  getSearchCursor(
    query: string | RegExp,
    start?: CodeMirror.Position,
    caseFold?: boolean
  ): CodeMirror.SearchCursor;
  getSelection(): CodeEditor.ITextSelection;
  getSelections(): CodeEditor.ITextSelection[];
  getTokenForPosition(position: CodeEditor.IPosition): CodeEditor.IToken;
  getTokens(): CodeEditor.IToken[];
  handleEvent(event: Event): void;
  hasFocus(): boolean;
  readonly host: HTMLElement;
  readonly isDisposed: boolean;
  // (undocumented)
  lastLine(): number;
  readonly lineCount: number;
  readonly lineHeight: number;
  readonly model: CodeEditor.IModel;
  newIndentedLine(): void;
  protected onKeydown(event: KeyboardEvent): boolean;
  // (undocumented)
  operation<T>(fn: () => T): T;
  redo(): void;
  refresh(): void;
  // (undocumented)
  removeOverlay(mode: string | object): void;
  resizeToFit(): void;
  revealPosition(position: CodeEditor.IPosition): void;
  revealSelection(selection: CodeEditor.IRange): void;
  // (undocumented)
  scrollIntoView(
    pos: {
      from: CodeMirror.Position;
      to: CodeMirror.Position;
    },
    margin: number
  ): void;
  // (undocumented)
  protected selectionMarkers: {
    [key: string]: CodeMirror.TextMarker[] | undefined;
  };
  selectionStyle: CodeEditor.ISelectionStyle;
  setCursorPosition(
    position: CodeEditor.IPosition,
    options?: {
      bias?: number;
      origin?: string;
      scroll?: boolean;
    }
  ): void;
  setOption<K extends keyof CodeMirrorEditor.IConfig>(
    option: K,
    value: CodeMirrorEditor.IConfig[K]
  ): void;
  setSelection(selection: CodeEditor.IRange): void;
  setSelections(selections: CodeEditor.IRange[]): void;
  setSize(dimension: CodeEditor.IDimension | null): void;
  // (undocumented)
  readonly state: any;
  undo(): void;
  uuid: string;
}

// @public
export namespace CodeMirrorEditor {
  export function addCommand(
    name: string,
    command: (cm: CodeMirror.Editor) => void
  ): void;
  export interface IConfig extends CodeEditor.IConfig {
    coverGutterNextToScrollbar?: boolean;
    dragDrop?: boolean;
    electricChars?: boolean;
    extraKeys?: any;
    fixedGutter?: boolean;
    foldGutter?: boolean;
    gutters?: string[];
    keyMap?: string;
    lineSeparator?: string | null;
    lineWiseCopyCut?: boolean;
    mode?: string | Mode.IMode;
    scrollbarStyle?: string;
    scrollPastEnd?: boolean;
    selectionPointer: boolean | string;
    showCursorWhenSelecting?: boolean;
    smartIndent?: boolean;
    styleActiveLine: boolean | CodeMirror.StyleActiveLine;
    styleSelectedText: boolean;
    theme?: string;
  }
  let defaultConfig: IConfig;
  export interface IOptions extends CodeEditor.IOptions {
    config?: Partial<IConfig>;
  }
}

// @public
export class CodeMirrorEditorFactory implements IEditorFactoryService {
  constructor(defaults?: Partial<CodeMirrorEditor.IConfig>);
  // (undocumented)
  protected documentCodeMirrorConfig: Partial<CodeMirrorEditor.IConfig>;
  // (undocumented)
  protected inlineCodeMirrorConfig: Partial<CodeMirrorEditor.IConfig>;
  newDocumentEditor: (options: CodeEditor.IOptions) => CodeMirrorEditor;
  newInlineEditor: (options: CodeEditor.IOptions) => CodeMirrorEditor;
}

// @public
export class CodeMirrorMimeTypeService implements IEditorMimeTypeService {
  getMimeTypeByFilePath(path: string): string;
  getMimeTypeByLanguage(info: nbformat.ILanguageInfoMetadata): string;
}

// @public
export const editorServices: IEditorServices;

// @public
export class EditorSyntaxStatus extends VDomRenderer<EditorSyntaxStatus.Model> {
  constructor(opts: EditorSyntaxStatus.IOptions);
  render(): JSX.Element;
}

// @public
export namespace EditorSyntaxStatus {
  export interface IOptions {
    commands: CommandRegistry;
  }
  export class Model extends VDomModel {
    editor: CodeEditor.IEditor | null;
    readonly mode: string;
  }
}

// @public
export namespace Mode {
  // (undocumented)
  export function addSpecLoader(loader: ISpecLoader, rank: number): void;
  export function ensure(mode: string | ISpec): Promise<ISpec>;
  export function findBest(mode: string | ISpec): ISpec;
  export function findByExtension(ext: string | string[]): ISpec;
  export function findByFileName(name: string): ISpec;
  export function findByMIME(mime: string): ISpec;
  export function findByName(name: string): ISpec;
  export function getModeInfo(): ISpec[];
  export interface IMode {
    // (undocumented)
    [key: string]: JSONValue;
    // (undocumented)
    name: string;
  }
  export interface ISpec {
    // (undocumented)
    ext?: string[];
    // (undocumented)
    mime: string;
    // (undocumented)
    mode: string;
    // (undocumented)
    name?: string;
  }
  export interface ISpecLoader {
    (spec: ISpec): Promise<boolean>;
  }
  export function run(
    code: string,
    mode: string | ISpec,
    el: HTMLElement
  ): void;
}

// (No @packageDocumentation comment for this package)
```
