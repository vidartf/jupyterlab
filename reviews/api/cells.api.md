## API Report File for "@jupyterlab/cells"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts
import { CodeEditor } from '@jupyterlab/codeeditor';
import { CodeEditorWrapper } from '@jupyterlab/codeeditor';
import { IAttachmentsModel } from '@jupyterlab/attachments';
import { IChangedArgs } from '@jupyterlab/coreutils';
import { IClientSession } from '@jupyterlab/apputils';
import { IModelDB } from '@jupyterlab/observables';
import { IObservableJSON } from '@jupyterlab/observables';
import { IObservableMap } from '@jupyterlab/observables';
import { IObservableValue } from '@jupyterlab/observables';
import { IOutputAreaModel } from '@jupyterlab/outputarea';
import { IOutputPrompt } from '@jupyterlab/outputarea';
import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
import { ISignal } from '@phosphor/signaling';
import { IStdin } from '@jupyterlab/outputarea';
import { IterableOrArrayLike } from '@phosphor/algorithm';
import { JSONObject } from '@phosphor/coreutils';
import { JSONValue } from '@phosphor/coreutils';
import { KernelMessage } from '@jupyterlab/services';
import { Message } from '@phosphor/messaging';
import { nbformat } from '@jupyterlab/coreutils';
import { ObservableValue } from '@jupyterlab/observables';
import { OutputArea } from '@jupyterlab/outputarea';
import * as React from 'react';
import { ReactWidget } from '@jupyterlab/apputils';
import { Signal } from '@phosphor/signaling';
import { Stdin } from '@jupyterlab/outputarea';
import { Widget } from '@phosphor/widgets';

// @public
export abstract class AttachmentsCell extends Cell {
  handleEvent(event: Event): void;
  readonly model: IAttachmentsCellModel;
  protected onAfterAttach(msg: Message): void;
  protected onBeforeDetach(msg: Message): void;
  protected abstract updateCellSourceWithAttachment(
    attachmentName: string
  ): void;
}

// @public
export class AttachmentsCellModel extends CellModel {
  constructor(options: AttachmentsCellModel.IOptions);
  readonly attachments: IAttachmentsModel;
  toJSON(): nbformat.IRawCell | nbformat.IMarkdownCell;
}

// @public
export namespace AttachmentsCellModel {
  export class ContentFactory implements IContentFactory {
    createAttachmentsModel(
      options: IAttachmentsModel.IOptions
    ): IAttachmentsModel;
  }
  export interface IContentFactory {
    createAttachmentsModel(
      options: IAttachmentsModel.IOptions
    ): IAttachmentsModel;
  }
  export interface IOptions extends CellModel.IOptions {
    contentFactory?: IContentFactory;
  }
  const defaultContentFactory: ContentFactory;
}

// @public
export class Cell extends Widget {
  constructor(options: Cell.IOptions);
  clone(): Cell;
  readonly contentFactory: Cell.IContentFactory;
  dispose(): void;
  readonly editor: CodeEditor.IEditor;
  readonly editorWidget: CodeEditorWrapper;
  protected handleInputHidden(value: boolean): void;
  initializeState(): this;
  readonly inputArea: InputArea;
  inputHidden: boolean;
  loadCollapseState(): void;
  loadEditableState(): void;
  readonly model: ICellModel;
  protected onActivateRequest(msg: Message): void;
  protected onAfterAttach(msg: Message): void;
  protected onFitRequest(msg: Message): void;
  protected onMetadataChanged(
    model: IObservableMap<JSONValue>,
    args: IObservableMap.IChangedArgs<JSONValue>
  ): void;
  protected onUpdateRequest(msg: Message): void;
  readonly promptNode: HTMLElement;
  readOnly: boolean;
  readonly ready: Promise<void>;
  saveCollapseState(): void;
  saveEditableState(): void;
  setPrompt(value: string): void;
  syncCollapse: boolean;
  syncEditable: boolean;
}

// @public
export namespace Cell {
  export class ContentFactory implements IContentFactory {
    constructor(options?: ContentFactory.IOptions);
    createCellFooter(): ICellFooter;
    createCellHeader(): ICellHeader;
    createInputPrompt(): IInputPrompt;
    createOutputPrompt(): IOutputPrompt;
    createStdin(options: Stdin.IOptions): IStdin;
    readonly editorFactory: CodeEditor.Factory;
  }
  export namespace ContentFactory {
    export interface IOptions {
      editorFactory?: CodeEditor.Factory;
    }
  }
  export interface IContentFactory
    extends OutputArea.IContentFactory,
      InputArea.IContentFactory {
    createCellFooter(): ICellFooter;
    createCellHeader(): ICellHeader;
  }
  export interface IOptions {
    contentFactory?: IContentFactory;
    editorConfig?: Partial<CodeEditor.IConfig>;
    model: ICellModel;
    updateEditorOnShow?: boolean;
  }
  const defaultContentFactory: ContentFactory;
}

// @public (undocumented)
export namespace CellDragUtils {
  export function createCellDragImage(
    activeCell: Cell,
    selectedCells: nbformat.ICell[]
  ): HTMLElement;
  export function detectTargetArea(
    cell: Cell,
    target: HTMLElement
  ): ICellTargetArea;
  export function findCell(
    node: HTMLElement,
    cells: IterableOrArrayLike<Cell>,
    isCellNode: (node: HTMLElement) => boolean
  ): number;
  // (undocumented)
  export type ICellTargetArea = 'input' | 'prompt' | 'cell' | 'unknown';
  export function shouldStartDrag(
    prevX: number,
    prevY: number,
    nextX: number,
    nextY: number
  ): boolean;
}

// @public
export class CellFooter extends Widget implements ICellFooter {
  constructor();
}

// @public
export class CellHeader extends Widget implements ICellHeader {
  constructor();
}

// @public
export class CellModel extends CodeEditor.Model implements ICellModel {
  constructor(options: CellModel.IOptions);
  readonly contentChanged: Signal<this, void>;
  readonly id: string;
  readonly metadata: IObservableJSON;
  protected onGenericChange(): void;
  onTrustedChanged(
    trusted: IObservableValue,
    args: ObservableValue.IChangedArgs
  ): void;
  readonly stateChanged: Signal<this, IChangedArgs<any, string>>;
  toJSON(): nbformat.ICell;
  trusted: boolean;
  readonly type: nbformat.CellType;
}

// @public
export namespace CellModel {
  export interface IOptions {
    cell?: nbformat.IBaseCell;
    id?: string;
    modelDB?: IModelDB;
  }
}

// @public
export class CodeCell extends Cell {
  constructor(options: CodeCell.IOptions);
  clone(): CodeCell;
  cloneOutputArea(): OutputArea;
  dispose(): void;
  protected handleInputHidden(value: boolean): void;
  initializeState(): this;
  loadCollapseState(): void;
  loadScrolledState(): void;
  readonly model: ICodeCellModel;
  protected onMetadataChanged(
    model: IObservableMap<JSONValue>,
    args: IObservableMap.IChangedArgs<JSONValue>
  ): void;
  protected onStateChanged(model: ICellModel, args: IChangedArgs<any>): void;
  readonly outputArea: OutputArea;
  outputHidden: boolean;
  outputsScrolled: boolean;
  saveCollapseState(): void;
  saveScrolledState(): void;
  syncScrolled: boolean;
}

// @public
export namespace CodeCell {
  export function execute(
    cell: CodeCell,
    session: IClientSession,
    metadata?: JSONObject
  ): Promise<KernelMessage.IExecuteReplyMsg | void>;
  export interface IOptions extends Cell.IOptions {
    model: ICodeCellModel;
    rendermime: IRenderMimeRegistry;
  }
}

// @public
export class CodeCellModel extends CellModel implements ICodeCellModel {
  constructor(options: CodeCellModel.IOptions);
  dispose(): void;
  executionCount: nbformat.ExecutionCount;
  onTrustedChanged(
    trusted: IObservableValue,
    args: ObservableValue.IChangedArgs
  ): void;
  readonly outputs: IOutputAreaModel;
  toJSON(): nbformat.ICodeCell;
  readonly type: 'code';
}

// @public
export namespace CodeCellModel {
  export class ContentFactory implements IContentFactory {
    createOutputArea(options: IOutputAreaModel.IOptions): IOutputAreaModel;
  }
  export interface IContentFactory {
    createOutputArea(options: IOutputAreaModel.IOptions): IOutputAreaModel;
  }
  export interface IOptions extends CellModel.IOptions {
    contentFactory?: IContentFactory;
  }
  const defaultContentFactory: ContentFactory;
}

// @public
export abstract class Collapser extends ReactWidget {
  constructor();
  readonly collapsed: boolean;
  protected abstract handleClick(e: React.MouseEvent<HTMLDivElement>): void;
  protected render(): React.ReactElement<any>;
}

// @public
export interface IAttachmentsCellModel extends ICellModel {
  readonly attachments: IAttachmentsModel;
}

// @public
export interface ICellFooter extends Widget {}

// @public
export interface ICellHeader extends Widget {}

// @public
export interface ICellModel extends CodeEditor.IModel {
  readonly contentChanged: ISignal<ICellModel, void>;
  readonly id: string;
  readonly metadata: IObservableJSON;
  readonly stateChanged: ISignal<ICellModel, IChangedArgs<any>>;
  toJSON(): nbformat.ICell;
  trusted: boolean;
  readonly type: nbformat.CellType;
}

// @public
export interface ICodeCellModel extends ICellModel {
  executionCount: nbformat.ExecutionCount;
  readonly outputs: IOutputAreaModel;
  toJSON(): nbformat.ICodeCell;
  readonly type: 'code';
}

// @public
export interface IInputPrompt extends Widget {
  executionCount: string;
}

// @public
export interface IMarkdownCellModel extends IAttachmentsCellModel {
  toJSON(): nbformat.IMarkdownCell;
  readonly type: 'markdown';
}

// @public
export class InputArea extends Widget {
  constructor(options: InputArea.IOptions);
  readonly contentFactory: InputArea.IContentFactory;
  dispose(): void;
  readonly editor: CodeEditor.IEditor;
  readonly editorWidget: CodeEditorWrapper;
  readonly model: ICellModel;
  readonly promptNode: HTMLElement;
  renderInput(widget: Widget): void;
  setPrompt(value: string): void;
  showEditor(): void;
}

// @public
export namespace InputArea {
  export class ContentFactory implements IContentFactory {
    constructor(options?: ContentFactory.IOptions);
    createInputPrompt(): IInputPrompt;
    readonly editorFactory: CodeEditor.Factory;
  }
  export namespace ContentFactory {
    export interface IOptions {
      editorFactory?: CodeEditor.Factory;
    }
  }
  export interface IContentFactory {
    createInputPrompt(): IInputPrompt;
    readonly editorFactory: CodeEditor.Factory;
  }
  export interface IOptions {
    contentFactory?: IContentFactory;
    model: ICellModel;
    updateOnShow?: boolean;
  }
  const defaultEditorFactory: CodeEditor.Factory;
  const defaultContentFactory: ContentFactory;
}

// @public
export class InputCollapser extends Collapser {
  constructor();
  readonly collapsed: boolean;
  protected handleClick(e: React.MouseEvent<HTMLDivElement>): void;
}

// @public
export class InputPlaceholder extends Placeholder {
  constructor(callback: (e: React.MouseEvent<HTMLDivElement>) => void);
  protected render(): React.ReactElement<any>[];
}

// @public
export class InputPrompt extends Widget implements IInputPrompt {
  constructor();
  executionCount: string;
}

// @public
export interface IRawCellModel extends IAttachmentsCellModel {
  toJSON(): nbformat.IRawCell;
  readonly type: 'raw';
}

// @public (undocumented)
export function isCodeCellModel(model: ICellModel): model is ICodeCellModel;

// @public (undocumented)
export function isMarkdownCellModel(
  model: ICellModel
): model is IMarkdownCellModel;

// @public (undocumented)
export function isRawCellModel(model: ICellModel): model is IRawCellModel;

// @public
export class MarkdownCell extends AttachmentsCell {
  constructor(options: MarkdownCell.IOptions);
  clone(): MarkdownCell;
  readonly model: IMarkdownCellModel;
  // (undocumented)
  protected onUpdateRequest(msg: Message): void;
  readonly ready: Promise<void>;
  rendered: boolean;
  protected renderInput(widget: Widget): void;
  protected showEditor(): void;
  protected updateCellSourceWithAttachment(attachmentName: string): void;
}

// @public
export namespace MarkdownCell {
  export interface IOptions extends Cell.IOptions {
    model: IMarkdownCellModel;
    rendermime: IRenderMimeRegistry;
  }
}

// @public
export class MarkdownCellModel extends AttachmentsCellModel {
  constructor(options: CellModel.IOptions);
  toJSON(): nbformat.IMarkdownCell;
  readonly type: 'markdown';
}

// @public
export class OutputCollapser extends Collapser {
  constructor();
  readonly collapsed: boolean;
  protected handleClick(e: React.MouseEvent<HTMLDivElement>): void;
}

// @public
export class OutputPlaceholder extends Placeholder {
  constructor(callback: (e: React.MouseEvent<HTMLDivElement>) => void);
  protected render(): React.ReactElement<any>[];
}

// @public
export abstract class Placeholder extends ReactWidget {
  constructor(callback: (e: React.MouseEvent<HTMLDivElement>) => void);
  protected handleClick(e: React.MouseEvent<HTMLDivElement>): void;
}

// @public
export class RawCell extends Cell {
  constructor(options: Cell.IOptions);
  clone(): RawCell;
  readonly model: IRawCellModel;
}

// @public
export namespace RawCell {
  export interface IOptions extends Cell.IOptions {
    model: IRawCellModel;
  }
}

// @public
export class RawCellModel extends AttachmentsCellModel {
  toJSON(): nbformat.IRawCell;
  readonly type: 'raw';
}

// (No @packageDocumentation comment for this package)
```
